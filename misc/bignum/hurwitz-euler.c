/* 
 * hurwitz-euler.c
 *
 * Compute the Hurwitz zeta function for arbitrary complex argument
 * Use the Euler-Maclaurin formla to do so.
 *
 * Linas Vepstas Feb 2007
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/times.h>
#include <stdint.h>
#include <unistd.h>


#include <gmp.h>
#include "mp-binomial.h"
#include "mp-cache.h"
#include "mp-complex.h"
#include "mp-misc.h"
#include "mp-polylog.h"
#include "mp-trig.h"
#include "mp-zeta.h"

/* =========================================================== */

	char * restr= "-0.2654851381085359315867945003255774589477572935708660925073463105254689304947451403400372345629019227197744604854325807423261778122947836735207785136792497223637154270456540359060381146855057077683625453529759469298476616014712154420406272412149455496795166127604635404451693685407333176518423384069610030960529864520347007869860719815268595344355790720250670562579045494878323133365489608421286614154727259419937350263966429913964761657884522208247862640813845738665376582750268705832301277864983267681029538709187362896384966142421316464971924121162723336560122312582824902641580174710135870857130151625432129643458791157555420696169622799696909005739582618593739077227959988068613796291856423663812757605375274831823791339760784333175588210353788221859627596723961557611670431617171683910152111059058095383455883208046889378506390109573617111409851872302705343151337104091551652664035521711135442166589339609196991306085309496327368772652672025961758711504940102425335099577120319757187628196077983009293808956202127883776481474957659409563097610597771977766127297706374338114589069146289013827454481465482587806193782774075567935970914234566366665425961585813926573253165425998637613868959700055295249033948881612684356963857623113290688210343801751849952151016484983705688880670579418606949947960074918222232186001908989550035824886839642757248303900858585755385212528687484866250692541000486320355805129409420117711714238226953209561272973846177605279490578969341567396657507322345634547570886967624242883509000156226190553544881143497349195564319669137447211632015615578511342853324246824131458004139421830394039409010627265229298705856767632690868976166681566294127959090310288467594249991060301360389064867687562244387668324882421269268961646164511045322686419830243210586043256817368204340346708475543602425786597284338157975221870670629192379241690219968957838210974583525773086446082187122213490592121807029212934643319379727395305233850094064516096708144739306258621425496963895788245518580412484085502160364921414038454470275689276137740656247019422999623177288131135799689438593010635180414060704038280333781230567803022212877803844001282074453875342711627314897484546207565172811254746785870569173846890096619891465383899569926522462279928508405385671381693460977967060676967851415966028856953200585332344064618038094578927710648093971066504767848381138242228537238645457498674805446212446064396129535206808550229805627628443514634613536300272609687305107779673977690086387226753215675747583322904497543334433481398334739660486398189517639122514057817269372694176759632833887870555294654238525571555860061609018079466105769830602125742183966229078936551917157150463900207336460808862614562678010937503212224103447199798040250725865273321868436318145083860825064444581153580122622744825432287844269945588143305318081847321091443402776539130587194333253605813499144531689799869378839717584771155841466573654186012005512134109504168251504335167795970183738593302080195204075492599663815689370776751880975855165231314695113884299673790431327246647582387163730172887536664492953518717511797031201452699009644675168628443799938305304800494175291342780502751919053625417577996328206265782044359906486443036748475236269304967634608349452764726922980155392330653314249203909866313564975664119199018887659938498532192998474764221022012379998480200445530535197709678490143658801001613842319248501563051586778566298996744556552490770135779714578414578720938953949156875543616416266516321405688750788750402793206324904594194353843690239531348654807345707160422286824120093093888895498467756860636341772255929378918110177887825739909795794266935068634085919582399461672826002308816701349756112573804949865192893870422363148625866962751646979721921406186337384551612682575504251226146417998388791667909361046770761089403309401398e1";

	char * imstr = "-0.1239773328867850268906754835587459550789360366894241416586440161711130213110015073277042605224828458381677241208328654189909462385034785576716935038968603648949226677037298515654593933800103072872409716149897654494152091296311699702323797321334026200795938429025995326040294073608338621103813716623603228847314539385556130350394629423137185340193827308678621640405099051027887322673850597370288719313033599632524768253992911383763955230311866690701805874481285575287169935245331891451694097830823744315564188050488116787286165848211956813453959667737005454259253681507657658082600348787889674681905314896183681621039784604874351411624086962726476668526345767407101242821057426951291673753057908751218910300952831209100768691995202188967177406434519834614053095696703763130251385877887528563832437668407662076740051759947613892454314855925602812040951829663481766335450801279978090703201471391682770017436599763146965525270133550508999249802851896200833117758649384026331276570399360368509882620156449448144586536550831395769310329735608615979268713566447701533151220114540896691876196754167308649516541848246820186606179319848321012994463173641129017465234504143919462356173454449327165627103771041977402922254744474213691560195749425871390798614172177503223945248033888392951891648088239905043681796523588528177468036723720217047044131086866005181660948561802340786648382424310594695172042874245900037835867235764491593677500694452962602635169300356797345371395353107685221414449001050878366392846647077712162258942162761623172365029538731859087787908122345437585158086189457938363859174197926224561513607193646503292511924837060749261867138665883312447560513674878289894526284350998791107667877391326785601585844008370855434115940928482743134490421486674419340839108170189354463885154251706755523354480042603308767345815572837697616245180647938736754032817967251859046008776449344095560980558159930688959231711717049153664415029839390465581502196189483066007297261566391938594296945858971914680589576321684449002948488940825673892881166553046022979673515064785819441068717757377480586101305088441626494810596169250534597761539379645263259056990298333191477198851859463887703967419778029449727505487553158421273647629565903594775814327070289727609034332725527484578393430388361734288062367779575460620146598454060588537890290305511570947334897083945888630019952277594849005161095186065718461607064313246697509048127423344541601554716378223187825870381640675191744164556794755576192542943373588673939189139400696421335023841420840498801779648347709564285529550774667850419601103910793848004363593182076677726511900948091394223632225769175942265289400049301942595294914374530586328322364826590264943162056158412502898143064282168693296235088295296124048954634512835079067887478125502959038252667416586756261368145793018946601022760626902890390752593726275184292963829603343811172993117387090145988832044926831299739616990538966941443838367333761058030460201821262854820811776390983036712358497943703985826377176500012002667906818118797672881433169146519659099569168181876969313417848002236609570353417792456865087888908112494157219388374827980945393755650683727323775735367124839118975184800084252907539955805831794196560231537631807112210186381771281005950947803219690203494836281958049096514183900068486741140356667515372225484897330712735880523714598835506836884814637800968123036490364083983625110549991175024947285637831085318106722828119413175563196103224943849580291912475202312960819319532766138572560626651951321263165800510854873637559074110918869303162869950308279977842159150635345606232320860667635961955622256536000566608229500803813179233721798403766142431430938748163417001794889120686045892270413467039655909463722208787628946378630111052306075283005783771677837497516451411609653369518511448452401788946848403997e1";

/* =========================================================== */
	
void zeta_euler(cpx_t zeta, cpx_t ess, cpx_t q, int em, int prec);

void do_perf (int prec)
{
	int i;

	printf ("#\n# graph of periodic zeta as function of precision \n#\n");
	int hz = sysconf (_SC_CLK_TCK);
	printf ("# clock ticks=%d\n#\n", hz);
	fflush (stdout);

	for (prec=20; prec <123123; prec *= 1.41)
	{
		/* Set the precision (number of binary bits) */
		int nbits = 3.3*prec+100;
		mpf_set_default_prec (nbits);

		printf ("%d\t%d\t", prec, nbits);

		cpx_t ess, zeta, zee, plog, expected;
		cpx_init (ess);
		cpx_init (zeta);
		cpx_init (zee);
		cpx_init (plog);
		cpx_init (expected);

		mpf_set_str (expected[0].re, restr, 10);
		mpf_set_str (expected[0].im, imstr, 10);
	
		mpf_t que;
		mpf_init (que);

		struct tms start, end;

		cpx_set_d (ess, 0.5, 14.134725);
		cpx_set_d (zee, 0.2, 0.0);
		mpf_set_d (que, 0.2);

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_hurwitz_zeta (zeta, ess, que, prec);
		times (&end);

		cpx_sub (zeta, zeta, expected);

		long rex, imx;
		mpf_get_d_2exp (&rex, zeta[0].re);
		mpf_get_d_2exp (&imx, zeta[0].im);
		rex = -0.30103 *rex;
		imx = -0.30103 *imx;
		if (imx < rex) rex = imx;
		printf ("%ld\t", rex);
		
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<100; i++)
			cpx_hurwitz_zeta (zeta, ess, que, prec);
		times (&end);
		intmax_t delta = end.tms_utime - start.tms_utime;
		delta *= 10;
		printf ("%jd\t", delta);
#endif

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_hurwitz_taylor (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_hurwitz_taylor (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
#endif
		
#if 1
		/* First we warm the cache */
		times (&start);
		cpx_hurwitz_euler (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_hurwitz_euler (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
#endif
		printf ("\n");

		cpx_clear (ess);
		cpx_clear (zeta);
		cpx_clear (zee);
		cpx_clear (plog);
		cpx_clear (expected);
		mpf_clear (que);

		fflush (stdout);
	}
}

/* Compute to high precision, monitor the precision */
void hiprec(cpx_t zeta, int prec)
{
	/* Set the precision (number of binary bits) */
	int nbits = 3.322*prec+2*3.14*3.32*prec+140;
	// nbits = 3.322*prec+ 7*prec + 140;
	nbits = 3.322*prec+ 140;
	mpf_set_default_prec (nbits);
	cpx_set_prec (zeta, nbits);

	cpx_t cq, ess, prevzeta;
	cpx_init (ess);
	cpx_init (cq);
	cpx_init (prevzeta);
	cpx_set (prevzeta, zeta);

	cpx_set_d (ess, 0.5, 14.134725);
	
	mpf_t que;
	mpf_init (que);
	mpf_set_d (que, 0.2);
	
	mpf_set (cq[0].re, que);
	mpf_set_ui (cq[0].im, 0);
	
	cpx_hurwitz_zeta (zeta, ess, que, prec);
	// cpx_hurwitz_taylor (zeta, ess, cq, prec);
	cpx_sub (ess, zeta, prevzeta);

	printf ("prec=%d ", prec);

	long rex, imx;
	mpf_get_d_2exp (&rex, ess[0].re);
	mpf_get_d_2exp (&imx, ess[0].im);
	rex = -0.30103 *rex;
	imx = -0.30103 *imx;
	if (imx < rex) rex = imx;
	printf ("prev=%ld ", rex);

	double vre = mpf_get_d (ess[0].re);
	printf ("vre = %g ", vre);

#if 0
	double vim = mpf_get_d (ess[0].im);
	printf ("vim = %g ", vim);
#endif

#if 1
	// gmp_printf ("re= %.220Ff ", zeta[0].re);
	printf ("re= ");
	mpf_out_str (stdout, 10, prec, zeta[0].re);
	
	printf (" im= ");
	mpf_out_str (stdout, 10, prec, zeta[0].im);
#endif
	printf ("\n");
	fflush (stdout);

	cpx_clear (ess);
	cpx_clear (cq);
	cpx_clear (prevzeta);
}

double err_est (cpx_t ess, int em, int pee)
{
	/* (2pi)^{-2p} ((s+2p)! / (s-1)!)  (M+a)^{-2p}*/
	cpx_t poch;
	cpx_init (poch);

	cpx_poch_rising (poch, ess, 2*pee);

	mpf_t pabs, den;
	mpf_init (pabs);
	mpf_init (den);

	cpx_abs (pabs, poch);

	double fden = 2*3.1416*em;
	mpf_set_d (den, fden);
	fp_log (den, den, 40);
	mpf_mul_ui (den,den, 2*pee);
	mpf_neg (den,den);
	fp_exp(den,den,40);
	
	mpf_mul (pabs,pabs, den);

	double po = mpf_get_d (pabs);

	cpx_clear (poch);
	mpf_clear (pabs);
	mpf_clear (den);
	return po;
}

int main ()
{
	int prec = 40;
	int i;

	/* Set the precision (number of binary bits) */
	mpf_set_default_prec (3.3*prec+140);
	mpf_set_default_prec (1000);

	cpx_t ess, zeta, z2, z3;
	cpx_init (ess);
	cpx_init (zeta);
	cpx_init (z2);
	cpx_init (z3);

	cpx_set_d (ess, 0.5, 4.0);
	cpx_set_d (ess, 2.0, 0.1);
	cpx_set_d (ess, 0.5, 14.134725);
	
	mpf_t que;
	mpf_init (que);
	mpf_set_d (que, 0.2);
	
	cpx_t cq;
	cpx_init (cq);
	mpf_set (cq[0].re, que);
	mpf_set_ui (cq[0].im, 0);
	
#if 1
	for (i=20; i < 10000; i*=1.5)
	// for (i=100; i > 10; i/=1.3)
	{
		hiprec (zeta, i);
	}
#endif
	
#if 0
	cpx_hurwitz_zeta (z2, ess, que, prec);
	fp_prt ("borwein ", z2[0].im);
	printf ("\n");

	cpx_hurwitz_taylor (z3, ess, cq, prec);
	fp_prt ("taylor  ", z3[0].im);
	printf ("\n");

	cpx_hurwitz_euler (zeta, ess, cq, prec);
	fp_prt ("euler   ", zeta[0].im);
	printf ("\n");
#endif

#if 0
	cpx_t expected;
	cpx_init (expected);
	mpf_set_str (expected[0].re, restr, 10);
	mpf_set_str (expected[0].im, imstr, 10);
	
	int em;
	for (i=20; i<50; i+=10)
	{
		em = i;
		// double err = err_est (ess, em, pee);
		// printf ("err=%g ", err);
		zeta_euler (zeta, ess, cq, em, prec);
		cpx_sub (zeta, zeta, expected);

		long rex, imx;
		mpf_get_d_2exp (&rex, zeta[0].re);
		mpf_get_d_2exp (&imx, zeta[0].im);
		rex = -0.30103 *rex;
		imx = -0.30103 *imx;
		if (imx < rex) rex = imx;
		
		printf ("m=%d ", em);
		printf ("prec=%ld ", rex);
		fp_prt ("eu-mac=", zeta[0].im);
		printf ("\n");
	}
#endif
	// do_perf (prec);
	return 0;
}

