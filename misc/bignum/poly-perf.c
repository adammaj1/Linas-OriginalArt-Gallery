/**
 * poly-perf.c
 *
 * Make comparative performance measurements for
 * polylog algorithms.
 *
 * January 2007
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/times.h>
#include <stdint.h>
#include <unistd.h>

#include "mp-complex.h"
#include "mp-consts.h"
#include "mp-gamma.h"
#include "mp-misc.h"
#include "mp-polylog.h"
#include "mp-trig.h"

/* ================================================================= */
/* precomputed values polylog for z=0.4+i0.3 and s=0.5+i14.134725 
 * Good to about 3560 decimal places. */
char * restr = "0.326516966291876896433618265259101451722041136878152099560492025517077618557903180478688811071948546295693090191028911114259876637634778060670829611140267045513017286663552331189670785048314640092073448005025575618997216582084010728159590844562503053292282756806706786999567678560286333571488767798438535687404851115193592486377604669370238445424662078542333641843514873737702226053176268816141395025087018676242774976200567369082403624579492299540947849419202832832819334944881651763299065612411699046719585225927919816530595100418186353645355490222895425398352031581791331946092540949894539792868542373806274233539477050770061250834479089876596500019734200977825390664633874468272984746082537218188310649666858871216911776104271217999846584311743833990434402590725895982600664220632714823172822486163172900301839767863740651102663369003112377825659757870974235807072151897036288833076631859690532394480553356377099849582823624457849471322717845307435978665350275690351223511663463008476315017468825908636775007214793206757422426717732921312026958160080443414670561674437671460794283554939867281592409355034760354850122249984550743094179383848091062942795237166874177550619961074353813658949955809157921916141233910309937078699658683405859395536570708953435003776464771174165664813116266237130087660245165427912998978275622198655471939564336687413343841273384966298714671383648111161056155975229016923392764290324838382094779107636424059136875160041141749573222694575034025746317605071560477105674500750332100990188198242128961743684707116440824766023413482569912337419525537095101232377649527068810089437675082873977701595699964658889124743697602982037394655863417188413693875041735760588567387085766821874546572176715387959617940083649484109071379529225191271790958481762708761507582441246782190279479212489268966750467519904480160968113061665213891203278236113692077306833540573567367203100218753723045408133101268257947213727959476372089841169399520642089429771684659155940841742200884422347358859914467239036891021758502288273490454452434742875274651261659650589013141271266229194616242631212346984746623159135251672932281153027514384134750402877570351068398144863152843161767751082862903312062162620099379668409863526498577150855034183812600447865054112383510181808078692160075368477459922880282700885018425024276284599980794732811653220824077551852873499930223367038421342072192139941656392777645654421598160233575604324410097843782443330639914540758626326571351358809400417310978785927553789729182503524728435434115812898316837290366457874945881132456894107026404712756585361512372035040130189584766868148351330999608761112604532515016635952415906116125707438526963692594231291704692595993015200775282533936579823415288868394857939285455447680539296544659097806404904868702213659388143219711030208805170345667973381830220795313132495109699963786729425199041419004731002931103437480323212633642611539995158244719647727098484640616361626215794917484917964808151771740939464640564540971333596068995321902245775358533913746753130979808528212357347667194384993203931411192284828292349057984423278188004547946619786855948088639757717131298909658073549022947029132679087786326719763676909249887600362921295723564234030064603364780767272295716875311483672055622920374368402957484487033870331989579059217302788765045817108838577937351352967055696463853655013420353742471666662780780905826830300021584371733972593608781083014810355372487888404623091126078869230545366776512120278970854933462850643371613486737113963879440888219863511016986326107985110756276674217422e0";
char * imstr = "0.119260261009310006540112866720212139819431019039786908382255430102296212766396347662996986085634677464531083763655415382083665035225497313637374547938071618857835995796915643605195971757849553532678699626720620796805830524221162649446897134504532842525279497084257505512708399155469382756140734242600718420462660345320959387844835751424883236861355380932404861698351509640110707004781671204068035682291668883816291156241976568124905988994727264661343212907209006059480555360953399567186574692313543049647441931086669882365398010735271516004977090946220181211791935585922586912373684882545710517552007152318606305167572401949596267908958081215500841092422286665410990244439343577562049717830460636806007106908991004106008422599249619499841958288311068643618828914822662743443940355769651625168417260987847837206941528420044652075819494284387790156277602224754333909276097123872180679432828968098689235189548601617447518157905990694609549615486133250788276169248780939330976047012825216042442029937208205739036564406942992031209139906329795252985060766532858793851154494389608370629177514184325447232310745197856316594164038489542829382115833719229345931482272026076616315177691666482352391765740693901052147330623403358575952285157772130493289452447488270458941996644675066352425196519374805255096908393064284625044243429975401632601479522406975057977635258274623407944936551844637524356748047715925688891627984017507151808424093811685294947969672715827264722673081385280699896074862046310222314796624918344881670711474771339854071704634614177049306132926999983629549498043578656952428178614660480556829884927101412941317960535566735866031182779349621803527604531163076425105921980449396700607262115180627140580778068352646138529645765716678381274457086837440852951209136162331450141881407818216686668248304486090279417799641071258775278232719173819019714585289766245122974368709474546081133345908930080771857444181050532281505559551045094563241014997506339941537387535374114712125029190101361843427018024294827689227091537319749713130008117032578312209658477637635608656776236469491291919298826830841012267624721969660049704664732428477470932980618456658955566183427048078738102889059995346750291311189421429850569576897978329890787266267089943464320918244279702641808818957874055279100681835320709123893589361772188280541705385185696424772694967613121206116629951327296544393531899398325954638010871991035725777606404084766746608015427260928679601480159941948086439621129697536789244192906479515984568241517397221914581244155179966530829907579869771780805631265741947946667759167894475361378823410826251916069099811861671379242685059745864924690406850324373841417810506994040175449461620204387190989255560689710810981349740438843892744938429670979183806632210256097530968669470537388853470884594581959258914035229579243918410335536009393485149981684099948498050385227953277118564621198875375674612522719350084961334195760576361606416786082497345527504683274638253871695744985159585085993592002624534639767394881385675893100752791633422290699096578011986867752366826133643259411063537161211147194912061487252746350093013851951826319378550524929303740250758351705165411060870122340284781953826004997563350758548689485118740754608994487144455949224917010749592132079633440244451104215589860954380445712294935036098511541299651092741655605276293204690782970757037919833233222727750570464381784114120776140658626251383960971912689169507419425653238970584880740470992580102201280137921887730488719090798538801439085953553743632418699225298505541771318189711058229946681e0";
/* ================================================================= */

void do_perf(void)
{
	int i;
	int prec = 40;
	int rex;

	printf ("#\n# graph of periodic zeta as function of precision \n#\n");
	int hz = sysconf (_SC_CLK_TCK);
	printf ("# clock ticks=%d\n#\n", hz);
	fflush (stdout);

	for (prec=10; prec <123123; prec *= 1.41)
	{
		/* Set the precision (number of binary bits) */
		int nbits = 3.32*prec+prec+100;
		mpf_set_default_prec (nbits);

		printf ("%d\t%d\t", prec, nbits);

		cpx_t ess, zeta, zee, plog, expected;
		cpx_init (ess);
		cpx_init (zeta);
		cpx_init (zee);
		cpx_init (plog);
		cpx_init (expected);
	
		mpf_t que;
		mpf_init (que);

		mpf_set_str (expected[0].re, restr, 10);
		mpf_set_str (expected[0].im, imstr, 10);
	
		struct tms start, end;

#define MEASURE_POLYLOG_PERFORMANCE 1
#ifdef MEASURE_POLYLOG_PERFORMANCE
		cpx_set_d (ess, 0.5, 14.134725);
		cpx_set_d (zee, 0.4, 0.3);

#if 1
		/* First we warm the cache */
		times (&start);
		cpx_polylog (zeta, ess, zee, prec);
		times (&end);

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);

		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
		
		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_polylog (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);
#endif

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_polylog_euler (zeta, ess, zee, prec);
		times (&end);

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);

		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
		
		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_polylog_euler (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);
#endif

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_polylog_sum (zeta, ess, zee, prec);
		times (&end);

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);

		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<100; i++)
			cpx_polylog_sum (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		cpx_sub (zeta, zeta, expected);
		rex = get_prec (zeta, prec);
		printf ("%d\t", rex);
#endif

		printf ("\n");
		fflush (stdout);
#endif

// #define MEASURE_HURWITZ_PERFORMANCE
#ifdef MEASURE_HURWITZ_PERFORMANCE
		cpx_set_d (ess, 0.5, 14.134725);
		cpx_set_d (zee, 0.2, 0.0);
		mpf_set_d (que, 0.2);

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_hurwitz_zeta (zeta, ess, que, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_hurwitz_zeta (zeta, ess, que, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
#endif

#if 0
		/* First we warm the cache */
		times (&start);
		cpx_hurwitz_taylor (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));

		/* Then with a hot cache */
		times (&start);
		for (i=0; i<1000; i++)
			cpx_hurwitz_taylor (zeta, ess, zee, prec);
		times (&end);
		printf ("%jd\t", (intmax_t) (end.tms_utime - start.tms_utime));
#endif
		printf ("\n");
#endif

		cpx_clear (ess);
		cpx_clear (zeta);
		cpx_clear (zee);
		cpx_clear (plog);
		cpx_clear (expected);
		mpf_clear (que);

		fflush (stdout);
	}
}

/* ================================================================= */


/* Compute to high precision, monitor the precision */
void hiprec(cpx_t zeta, int prec)
{
	/* Set the precision (number of binary bits) */
	int nbits = 3.322*prec+2*3.14*3.32*prec+140;
	nbits = 3.322*prec+ 7*prec + 140;
	// nbits = 3.322*prec+ 140;
	nbits = 3.322*prec+ prec+ 140;
	mpf_set_default_prec (nbits);
	cpx_set_prec (zeta, nbits);

	cpx_t cq, ess, prevzeta;
	cpx_init (ess);
	cpx_init (cq);
	cpx_init (prevzeta);
	cpx_set (prevzeta, zeta);

	cpx_set_d (ess, 0.5, 14.134725);
	cpx_set_d (cq, 0.4, 0.3);
	
	// cpx_polylog_euler (zeta, ess, cq, prec);
	cpx_polylog (zeta, ess, cq, prec);
	cpx_sub (ess, zeta, prevzeta);

	printf ("prec=%d ", prec);

	long rex = get_prec (ess, prec);
	printf ("prev=%ld ", rex);

#if 0
	double vre = mpf_get_d (ess[0].re);
	printf ("vre = %g ", vre);

	double vim = mpf_get_d (ess[0].im);
	printf ("vim = %g ", vim);
#endif

#if 1
	// gmp_printf ("re= %.220Ff ", zeta[0].re);
	printf ("re= ");
	mpf_out_str (stdout, 10, prec, zeta[0].re);
	
	printf (" im= ");
	mpf_out_str (stdout, 10, prec, zeta[0].im);
#endif
	printf ("\n");
	fflush (stdout);

	cpx_clear (ess);
	cpx_clear (cq);
	cpx_clear (prevzeta);
}

/* ================================================================= */

int
main (int argc, char * argv[])
{
#if 0
	if (argc != 2)
	{
		fprintf (stderr, "Usage: %s <sim>\n", argv[0]);
		exit (1);
	}
	double sim = atof (argv[1]);
#endif

#if 0
	cpx_t zeta;
	cpx_init (zeta);
	int prec;
	for (prec=10; prec<15001; prec *= 1.4)
	{
		hiprec(zeta, prec);
	}
#endif
	
	do_perf();
	
	return 0;
}
