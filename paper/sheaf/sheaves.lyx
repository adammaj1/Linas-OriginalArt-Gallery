#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass amsart
\begin_preamble
\usepackage{url} 

  \definecolor{docnotelinkcolor}{rgb}{0,0,0.4}
\end_preamble
\use_default_options false
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "courier" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Graph Quotients: A Topological Approach to Graphs
\end_layout

\begin_layout Author
Linas Vep≈°tas
\end_layout

\begin_layout Date
7 November 2017
\end_layout

\begin_layout Abstract
This document develops general concepts useful for extracting knowledge
 embedded in large graphs or datasets that have pair-wise relationships,
 such as cause-effect-type relations.
 Almost no underlying assumptions are made, other than that the data can
 be presented in terms of pair-wise relationships between objects/events.
 This assumption is used to mine for patterns in the dataset, defining a
 reduced graph or dataset that boils-down or concentrates information into
 a more compact form.
 The resulting extracted structure or set of patterns are manifestly symbolic
 in nature, as they capture and encode the graph structure of the dataset
 in terms of a (generative) grammar.
\end_layout

\begin_layout Section*
Intro
\end_layout

\begin_layout Standard
This document presents some definitions and vocabulary for working with
 datasets that contain complex relationships, applicable to a large variety
 of application domains.
 The concepts borrow from graph theory, and several other areas of mathematics.
 The goal is to define a way of thinking about complex graphs, and how they
 can be simplified and condensed into simpler graphs that 
\begin_inset Quotes eld
\end_inset

concentrate
\begin_inset Quotes erd
\end_inset

 embedded knowledge into a more manageable size.
 The output of the process is a grammar that summarizes or captures the
 significant or important relationships.
\end_layout

\begin_layout Standard
The ideas described here are not terribly complex; they represent a kind-of
 
\begin_inset Quotes eld
\end_inset

folk knowledge
\begin_inset Quotes erd
\end_inset

 generally known to a number of practitioners.
 However, I am not currently aware of any kind of presentation of this informati
on, either in review/summary form, or as a fully articulated book or text.
 The background knowledge appears to be scattered across wide domains, and
 occur primarily in highly abstract settings, outside of the mainstream
 computer-science and data-analysis domain.
 Thus, this document tries to provide an introduction to these concepts
 in a plain-spoken language.
 The hope is to be precise enough that there will be few complaints from
 the mathematically rigorous-minded, yet simple enough that 
\begin_inset Quotes eld
\end_inset

anyone
\begin_inset Quotes erd
\end_inset

 can follow through and understand.
\end_layout

\begin_layout Standard
Some examples are provided, primarily drawn from linguistics.
 However, the concepts are generally applicable, and should prove useful
 for analyzing any kind of dataset expressed with pair-wise relationships,
 but containing hidden (non-obvious) complex cause-and-effect relationships.
 Such datasets include genomic and proteomic data, social-graph data, and
 even such social policy information.
\end_layout

\begin_layout Standard
Consider the example of determining the effectiveness of educational curricula.
 When teaching students, one never teaches advanced topics until foundations
 are laid.
 Yet many students struggle.
 Given raw data on a large sample of students, and the curricula they were
 subjected to, can one discern sequences and dependencies of cause-and-effect
 in this data? Can one find the most effective curriculum to teach, that
 advances the greatest number of students? Can one discover different classes
 of students, some who respond better to one style than another? My belief
 is that these questions can not only be answered, but that the framework
 described here can be used to uncover this structure.
\end_layout

\begin_layout Standard
Another example might be the analysis of motives and actions in humans.
 This includes analysis from real life, as well as the narratives of books
 and movies.
 In a book setting, the author cannot easily put characters into action
 until some basic sketch of personality and motives is developed.
 Motives can't be understood until a setting is established.
 If one can break down a large number of books/movies into pairs of related
 facts/scenes/remarks/actions, one can then extract a grammar of relationships,
 to see exactly what is involved in the movement of a narrative from here
 to there.
\end_layout

\begin_layout Standard
Much of this document is devoted to stating definitions for a few key structures
 used to talk about the general problem of discerning relationships and
 structure.
 The definitions are inspired by and draw upon concepts from algebraic topology,
 but mostly avoid both the rigor and the difficulty of that topic.
 
\end_layout

\begin_layout Standard
The definitions provide a framework, rather than an algorithm.
 It is up to the user to provide some mechanism for judging similarity -
 and this can be anything: some neural net, Bayesian net, Markov chain,
 or some vector space or SVM-style technique; the overall framework is agnostic
 as to these details.
 The goal is to provide a way of talking about, thinking about and presenting
 data so that the important knowledge contained in it is captured and described,
 boiled down to a manageable, workable state from a large raw dump of pair-relat
ionship data.
\end_layout

\begin_layout Standard
Currently, the ideas described here are employed in a machine-learning project
 that attempts to extract the structure of natural language in an unsupervised
 way.
 Thus, the primary, detailed examples will come from the natural language
 domain.
 The theory should be far more general than that.
\end_layout

\begin_layout Standard
This document resides in, accompanies source code that implements the ideas
 here.
 Specifically, it is in 
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/opencog/atomspace/tree/master/opencog/sheaf"
target "https://github.com/opencog/atomspace/tree/master/opencog/sheaf"

\end_inset

 and it spills over into other files, such as 
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/opencog/opencog/blob/master/ opencog/nlp/learn/scm/gram-class.scm"
target "https://github.com/opencog/opencog/blob/master/opencog/nlp/learn/scm/gram-class.scm"

\end_inset

 This code is in active development, and is likely to have changed by a
 lot since this was written.
 This document is 
\emph on
not
\emph default
 intended to describe the code; rather, it is meant to describe the general
 underlying concepts.
\end_layout

\begin_layout Standard
For the mathematically inclined, please be aware that the concepts described
 here touch on the tiniest tips of some very deep mathematical icebergs,
 specifically in parsing, type theory and category theory.
 I have no hope of providing the needed background, as these fields are
 sophisticated and immense.
 The reader is encouraged to study these on their own, especially as they
 are applied in computer science and linguistics.
 There are many good texts on these topics.
\end_layout

\begin_layout Standard
This document is organized as follows.
 The first part of provides a definition of a 
\begin_inset Quotes eld
\end_inset

section
\begin_inset Quotes erd
\end_inset

 of a graph.
 A section is a lot like a subgraph, except that it explicitly indicates
 which edges were cut to form the subgraph.
 The next part makes use of this concept of 
\begin_inset Quotes eld
\end_inset

sections
\begin_inset Quotes erd
\end_inset

 to show how they can be used to talk about and understand pattern-mining,
 clustering and quotienting.
 The next part indicates how such clusters can be understood to be 
\begin_inset Quotes eld
\end_inset

types
\begin_inset Quotes erd
\end_inset

, in the formal sense of mathematical type theory.
 Next follows a brief review of the concept of parsing, as it applies to
 this context.
 The ability to parse is what motivates the data discovery to begin with:
 after extracting patterns from a dataset, parsing is how those patterns
 can be re-assembled.
 An important part of pattern mining is the ability to distinguish polymorphic
 behavior.
 The final part shows how the system as a whole can be understood to be
 a kind of a sheaf, borrowing a concept from a different branch of mathematics.
\end_layout

\begin_layout Section*
Sections
\end_layout

\begin_layout Standard
Begin with the standard definition of a graph.
\end_layout

\begin_layout Definition*
A 
\noun on
graph
\noun default
 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 is an ordered pair 
\begin_inset Formula $\left(V,E\right)$
\end_inset

 of two sets, the first being the set 
\begin_inset Formula $V$
\end_inset

 of vertices, and the second being the set 
\begin_inset Formula $E$
\end_inset

 of edges.
 An edge 
\begin_inset Formula $e\in E$
\end_inset

 is a pair 
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset

 of vertices, where every 
\begin_inset Formula $v_{k}$
\end_inset

 
\emph on
must
\emph default
 be a member of 
\begin_inset Formula $V$
\end_inset

.
 That is, edges in 
\begin_inset Formula $E$
\end_inset

 can only connect vertexes in 
\begin_inset Formula $V$
\end_inset

, and not to something else.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
For directed graphs, the vertex ordering in the edge matters.
 For undirected graphs, it does not.
 The subsequent will mostly leave this distinction unspecified, and allow
 either (or both) directed and undirected edges, as the occasion and the
 need fits.
 Distinguishing between directed and undirected graphs is not important,
 at this point.
 In most of what follows, it will usually be assumed that there are no edges
 with 
\begin_inset Formula $v_{1}=v_{2}$
\end_inset

 (loops that connect back to themselves) and that there is at most one edge
 connecting any given pair of vertexes.
 These assumptions are being made to simplify the discussion; they are not
 meant to be a fundamental limitation.
 It just makes things easier to talk about and less cluttered at the start.
 The primary application does not require either construct, and it is straight-f
orward to add extensions to provide these features.
 Similar remarks apply to graphs with labeled vertexes or edges (such as
 
\begin_inset Quotes eld
\end_inset

colored
\begin_inset Quotes erd
\end_inset

 edges, vertexes or edges with numerical weights on them, 
\emph on
etc
\emph default
).
 Just keep in mind that such additional markup may appear out of thin air,
 later on.
\end_layout

\begin_layout Standard
Besides the above definition, there are other ways of defining and specifying
 graphs.
 The one that will be of primary interest here will be one that defines
 graphs as a collection of sections.
 These, in turn, are composed of seeds.
\end_layout

\begin_layout Definition*
A 
\noun on
seed
\noun default
 is a vertex and the set of edges that connect to it.
 That is, it is the pair 
\begin_inset Formula $\left(v,E_{v}\right)$
\end_inset

 where 
\begin_inset Formula $v$
\end_inset

 is a single vertex, and 
\begin_inset Formula $E_{v}$
\end_inset

 is a set of edges containing that vertex, i.e.
 that set of edges having 
\begin_inset Formula $v$
\end_inset

 as one or the other endpoint.
 The vertex 
\begin_inset Formula $v$
\end_inset

 may be called the 
\noun on
germ
\noun default
 of the seed.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
It should be clear that, given a graph 
\begin_inset Formula $G$
\end_inset

, one can equivalently describe it as a set of seeds (one simply lists all
 of the vertexes, and all of the edges attached to each vertex).
 The converse is not 
\begin_inset Quotes eld
\end_inset

naturally
\begin_inset Quotes erd
\end_inset

 true.
 Consider a single seed, consisting of one vertex 
\begin_inset Formula $v_{1}$
\end_inset

, and a single edge 
\begin_inset Formula $e=\left(v_{1},v_{2}\right)$
\end_inset

.
 Then the pair 
\begin_inset Formula $\left(V,E\right)$
\end_inset

 with 
\begin_inset Formula $V=\left\{ v_{1}\right\} $
\end_inset

 and 
\begin_inset Formula $E=\left\{ \left(v_{1},v_{2}\right)\right\} $
\end_inset

 is 
\emph on
not
\emph default
 a graph, because 
\begin_inset Formula $v_{2}$
\end_inset

 is missing from the set 
\begin_inset Formula $V$
\end_inset

.
 Of course, we could implicitly include 
\begin_inset Formula $v_{2}$
\end_inset

 in the collection of vertexes, but this is not 
\begin_inset Quotes eld
\end_inset

natural
\begin_inset Quotes erd
\end_inset

, if one is taking the germs of the seeds to define the vertexes of the
 graph.
\end_layout

\begin_layout Standard
Thus, given a seed, each edge in that seed has one 
\begin_inset Quotes eld
\end_inset

connected
\begin_inset Quotes erd
\end_inset

 endpoint, and one 
\begin_inset Quotes eld
\end_inset

unconnected
\begin_inset Quotes erd
\end_inset

 endpoint.
 The 
\begin_inset Quotes eld
\end_inset

connected
\begin_inset Quotes erd
\end_inset

 endpoint is that endpoint that is 
\begin_inset Formula $v$
\end_inset

.
 The other endpoint will commonly be called the 
\noun on
connector
\noun default
; equivalently, the edge can be taken to be the connector.
 Perhaps it should be called a half-edge, as one end-point is specified,
 but missing.
\end_layout

\begin_layout Standard
The seed can be visualized as a ball, with a bunch of sticks sticking out
 of it.
 A burr one might collect on one's clothing.
 One can envision a seed as an analog of an open set in topology: the center
 (the germ) is part of the set, and then there's some more, but the boundary
 is not part of the set.
 The vertexes on the unconnected ends of the edges are not a part of the
 seed.
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A seed
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename seed.eps
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Just as one can cover a topological space with a collection of open sets,
 so one can also cover a graph with seeds.
 This analogy is firm: if one has open sets 
\begin_inset Formula $U_{i}$
\end_inset

 and 
\begin_inset Formula $U_{j}$
\end_inset

 and 
\begin_inset Formula $U_{i}\cap U_{j}\ne\emptyset$
\end_inset

 then one can take 
\begin_inset Formula $U_{i}$
\end_inset

 and 
\begin_inset Formula $U_{j}$
\end_inset

 to be vertices, and 
\begin_inset Formula $U_{i}\cap U_{j}$
\end_inset

 to be an edge running between them.
\end_layout

\begin_layout Standard
More definitions are needed to advance the ideas of connecting and covering.
\end_layout

\begin_layout Definition*
A 
\noun on
section
\noun default
 is a set of seeds.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
It should be clear that a graph 
\begin_inset Formula $G$
\end_inset

 can be expressed as section; that section has the nice property that all
 of the germs appear once (and only once) in the set 
\begin_inset Formula $V$
\end_inset

 of 
\begin_inset Formula $G$
\end_inset

, and that all of the edges in 
\begin_inset Formula $E$
\end_inset

 appear twice, once each in two distinct seeds.
 This connectivity property motivates the following definition: 
\end_layout

\begin_layout Definition*
Given a section 
\begin_inset Formula $S$
\end_inset

, a 
\noun on
link
\noun default
 is any edge 
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset

 where both 
\begin_inset Formula $v_{1}$
\end_inset

 and 
\begin_inset Formula $v_{2}$
\end_inset

 appear as germs of seeds in 
\begin_inset Formula $S$
\end_inset

.
 Two seeds are 
\noun on
connected
\noun default
 when there is a link between them.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Two linked (connected) seeds
\end_layout

\end_inset


\begin_inset Graphics
	filename seeds-two.eps
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The use of links allows the concepts of paths and connectivity, taken from
 graph theory, to be imported into the current context.
 Thus, one can obviously define:
\end_layout

\begin_layout Definition*
A 
\noun on
connected section
\noun default
, or a 
\noun on
contiguous section
\noun default
 is a section where every germ is connected to every other germ via a path
 through the edges.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
In graph theory, this would normally be called a 
\begin_inset Quotes eld
\end_inset

connected graph
\begin_inset Quotes erd
\end_inset

, but we cannot fairly call it that because the seeds and sections were
 defined in such a way that they are not graphs; they only become graphs
 when they are fully connected.
 Never-the-less, it is fairly safe and straight-forward to apply common
 concepts from graph-theory.
 Sections are almost like graphs, but not quite.
\end_layout

\begin_layout Standard
Note that there are two types of edges in a section: those edges that connect
 to nothing, and those edges that connect to other seeds in that section.
 Henceforth, the unconnected edges will be called connectors (as defined
 above), while the fully-connected edges will be called links (also defined
 above).
 Connectors can be thought of as a kind-of half-edge: incomplete, missing
 the far end, while links are fully connected, whole.
\end_layout

\begin_layout Standard
Seeds and sections can (and should!) be visualized as hedgehogs - a body
 with spines sticking out of it - the connectors can be thought of as the
 spiny bits sticking out, waiting to make a connection, while the hedgehog
 body is that collection of vertices and the fully-connected links between
 them.
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A connected section
\end_layout

\end_inset


\begin_inset Graphics
	filename hedgehog.eps
	width 30col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Implicit in the above definitions was that, during link formation, an edge
 is only allowed to connect to another seed if and only if the connector
 matches the germ.
 That is, if 
\begin_inset Formula $\left(v_{1},v_{2}\right)$
\end_inset

 is an edge rooted in the seed for 
\begin_inset Formula $v_{1}$
\end_inset

 and if 
\begin_inset Formula $\left(v_{3},v_{4}\right)$
\end_inset

 is an edge rooted in the seed for 
\begin_inset Formula $v_{3}$
\end_inset

, then these two can form a link if and only if 
\begin_inset Formula $v_{2}=v_{3}$
\end_inset

 and 
\begin_inset Formula $v_{4}=v_{1}$
\end_inset

.
 That is, the connectors are typed: they can only connect to seeds that
 are of the same type as the unconnected end of the edge.
\end_layout

\begin_layout Standard
This motivates a different way of looking at seeds: they can be visualized
 as jigsaw puzzle pieces, where any given tab on one jigsaw piece can fit
 into one and only one slot on another jigsaw piece.
 This union of a tab+slot is the link.
 The types of the connectors will later be seen to be the same thing as
 the types of type theory; that is, they are bona-fide types.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Joining two connectors to form a link
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename puzzle.eps
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The jigsaw puzzle-piece illustration is not uncommon in the literature;
 such illustrations are explicitly depicted in a variety of settings.
\begin_inset CommandInset citation
LatexCommand cite
key "Sleator1991,Coecke2010,Kart2014,Baez2009"

\end_inset


\end_layout

\begin_layout Subsection*
Why sections?
\end_layout

\begin_layout Standard
Whats the point of introducing this seemingly non-standard approach to something
 that looks a lot like graph theory? There are several reasons.
\end_layout

\begin_layout Itemize
From a computational viewpoint, sections have nice properties that a list
 of vertexes and edges do not.
 Given a single seed, one 
\begin_inset Quotes eld
\end_inset

instantly
\begin_inset Quotes erd
\end_inset

 knows 
\emph on
all
\emph default
 of the edges attached to its germ: they are listed right there.
 By contrast, given only a graph description, one has to search the entire
 list 
\begin_inset Formula $E$
\end_inset

 for any edges that might contain the given vertex.
 Computationally, searching large lists is inefficient, especially so for
 very large graphs.
\end_layout

\begin_layout Itemize
The subset of a section is always a section.
 This is not the case for a graph: given 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

, some arbitrary subset of 
\begin_inset Formula $V$
\end_inset

 and some arbitrary subset of 
\begin_inset Formula $E$
\end_inset

 do not generally form a graph; one has to apply consistency conditions
 to get a subgraph.
\end_layout

\begin_layout Itemize
A connected section behaves very much like a seed: just as two seeds can
 be linked together to form a connected section, so also two connected sections
 can be linked together to form a larger connected section.
 Both have a body, with spines sticking out.
 The building blocks (seeds), and the things built from them (sections)
 have the same properties, lie in the same class.
 Thus, one has a system that is naturally 
\begin_inset Quotes eld
\end_inset

scalable
\begin_inset Quotes erd
\end_inset

, and allows notions of similarity and scale invariance to be explored.
 There is no need to introduce additional concepts and constructions.
\end_layout

\begin_layout Itemize
Given two seeds, one can always either join them (because they connect)
 or it is impossible to connect them.
 Either way, one knows immediately.
 Graphs, in general, cannot be joined, unless one specifies a subgraph in
 each that matches up.
 Locating subgraphs in a graph is computationally expensive; verifying subgraph
 isomorphism is computationally expensive.
\end_layout

\begin_layout Itemize
Readers familiar with Link Grammar
\begin_inset CommandInset citation
LatexCommand cite
key "Sleator1991"

\end_inset

 should have recognized seeds as being more or less the same thing as 
\begin_inset Quotes eld
\end_inset

disjuncts
\begin_inset Quotes erd
\end_inset

 in Link Grammar.
 However, Link Grammar disjuncts are a bit more complicated than seeds;
 this is the topic of the next section.
\end_layout

\begin_layout Itemize
In certain ways, the connectors on a seed look like the uncontracted indexes
 on a tensor.
 That is, a seed with 
\begin_inset Formula $n$
\end_inset

 connectors on it looks like a tensor of order 
\begin_inset Formula $n$
\end_inset

.
 A link looks like a pair of indexes that have been contracted.
 Tensors have additional properties that seeds do not have; however, the
 notion of connecting together connectors to form links means that many
 of the notions from a tensor algebra can be carried over into the current
 context.
 This includes, at least partly, the notion that a tensor category describes
 the algebra of sections.
\end_layout

\begin_layout Itemize
The analogy between graphs and topology, specifically between open sets
 and seeds and the intersection of open sets and edges, allows concepts
 and tools to be borrowed from algebraic topology.
\end_layout

\begin_layout Standard
If we stop here, not much is accomplished, other than to define a somewhat
 idiosyncratic view of graph theory.
 But that is not the case; the concept of seeds and sections are needed
 to pursue more complex constructions.
 They provide a tool to study natural language and other systems.
\end_layout

\begin_layout Subsection*
Similar concept: lambda notation
\end_layout

\begin_layout Standard
Linguistics literature sometimes describes similar concepts using a lambda-calcu
lus notation.
 For example, one can sort-of envision the expression 
\begin_inset Formula $\lambda M.xyz$
\end_inset

 as a seed with the germ 
\begin_inset Formula $M$
\end_inset

 and with connectors 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

 and 
\begin_inset Formula $z$
\end_inset

.
 This notation has been used to express the concept of a seed, as described
 above.
\begin_inset CommandInset citation
LatexCommand cite
key "Poon2009"

\end_inset

 The problem with this notation is that, properly speaking, lambda calculus
 is a system for generating and working with strings, not with graphs, and
 lambdas are designed to perform substitution (beta-reduction), and not
 for connecting things.
 
\end_layout

\begin_layout Standard
That is, lambda terms are always strings of symbols, and the variables bound
 by the lambda are used to perform substitutions.
 To illustrate the issue, suppose that 
\begin_inset Formula $M$
\end_inset

 above is 
\begin_inset Formula $axbyczd$
\end_inset

 and suppose that 
\begin_inset Formula $\lambda N.w=ewf$
\end_inset

.
 Can these be 
\begin_inset Quotes eld
\end_inset

connected
\begin_inset Quotes erd
\end_inset

 together, linked together like seeds? No: if one tried to 
\begin_inset Quotes eld
\end_inset

connect
\begin_inset Quotes erd
\end_inset

 
\begin_inset Formula $N$
\end_inset

 to 
\begin_inset Formula $z,$
\end_inset

 one has the beta-reduction 
\begin_inset Formula $(\lambda M.xyz)\lambda N.w\rightarrow\lambda axbycewfd.xyw$
\end_inset

.
 There is no way to express some symmetric version of this, because 
\begin_inset Formula $(\lambda N.w)\lambda M.xyz\rightarrow\lambda eaxbyczdf.xyz$
\end_inset

 which is hardly the same.
 Now, of course, lambda calculus has great expressive power, and one could
 invent a way encoding graph theory, and/or seeds, in lambda calculus; however,
 doing so would result in verbose and complex system.
 Its easier to work with graphs directly, and just sleep peacefully with
 the knowledge that one could encode them with lambdas, if that is what
 your life depended on.
\end_layout

\begin_layout Standard
Note also that there have been extensions of the ideas of lambda calculus
 to graphs; however, those extensions cling to the fundamental concept of
 beta reduction.
 Thus, one works with graphs that have variables in them.
 Given a variable, one plugs in a graph in the place of that variable.
 The OpenCog 
\begin_inset CommandInset href
LatexCommand href
name "PutLink"
target "http://wiki.opencog.org/w/PutLink"

\end_inset

 works in exactly this way.
 The beta-reduction is fundamentally not symmetrical: putting A into B is
 not the same as putting B into A.
 The concept of 
\begin_inset Quotes eld
\end_inset

connecting
\begin_inset Quotes erd
\end_inset

 in a symmetric way doesn't arise.
\end_layout

\begin_layout Subsection*
Similar concept: history
\end_layout

\begin_layout Standard
Some first-principles applications of Bayesian models to natural language
 explicitly make use of a sequential order, called the 
\begin_inset Quotes eld
\end_inset

history
\begin_inset Quotes erd
\end_inset

 of a document.
\begin_inset CommandInset citation
LatexCommand cite
key "Rosen1996"

\end_inset

 That is, the probability of observing the the 
\begin_inset Formula $n$
\end_inset

-th word of a sequence is taken to be 
\begin_inset Formula $P(w_{n}|h)$
\end_inset

 where 
\begin_inset Formula $h=w_{n-1},w_{n-2},\cdots,w_{1}$
\end_inset

 is termed the history.
 This conception of probability is sharply influenced by the theory of Markov
 processes and finite-state machines, dating back to the dawn of information
 theory.
\begin_inset CommandInset citation
LatexCommand cite
key "Ash1965"

\end_inset

 In a finite-state process model, the future state is predicated only on
 the current state, and thus the Markov assumption holds.
 In deciphering such a process, one might not know how the current state
 is corellated to the output symbol, thus leading to the concept of a Hidden
 Markov Model (HMM).
 The concept of 
\begin_inset Quotes eld
\end_inset

history
\begin_inset Quotes erd
\end_inset

 is well-suited for such analysis.
 Several issues, however, make this approach impractical for many common
 problems.
\end_layout

\begin_layout Standard
One issue, already noted, is the linearity.
 One can try to hand-wave away this issue: given a graph of vertices, its
 sufficient to write the vertexes in some order, any order will do.
 This obsucres the fact that 
\begin_inset Formula $n$
\end_inset

 vertexes have 
\begin_inset Formula $n!$
\end_inset

 (
\begin_inset Formula $n$
\end_inset

-factorial) possible interactions: a combinatorial explosion, when the actual
 data graph may have a much much smaller number of interactions between
 vertexes (aka 
\begin_inset Quotes eld
\end_inset

edges
\begin_inset Quotes erd
\end_inset

).
 By encoding the known interactions as edges, a graphical approach avoids
 such a combinatorial explosion from the outset.
\end_layout

\begin_layout Standard
A different stumbling block of the 
\begin_inset Quotes eld
\end_inset

history
\begin_inset Quotes erd
\end_inset

 approach is that it ignores 
\begin_inset Quotes eld
\end_inset

the future
\begin_inset Quotes erd
\end_inset

: the fact that the words I might say next have already influenced the choice
 of the words I've already said.
 This can be hand-waved away by stating that the history is creating a model
 of (hidden) mental states, and that this model already incorporates those,
 and thus is anticipating future speech actions.
 Although this might be philosophically acceptable to some degree, it again
 forces complexity onto the problem, when the complexity is not needed.
 If you've already got the document, look at all of it; don't arbitrarily
 divide it into past and future, and discard the future.
\end_layout

\begin_layout Standard
To summarize: graphical structures appear naturally; flattening them into
 sequences places one at a computational disadvantage, even if the flattening
 is conceptually isomorphic to the original problem.
\end_layout

\begin_layout Section*
Clustering and Quotienting
\end_layout

\begin_layout Standard
The intended interpretation for the graphs discussed in this document is
 that they represent or are the result of capturing a large amount of collected
 raw data.
 From this data, one wants to extract commonalities and recurring patterns.
 
\end_layout

\begin_layout Standard
The core assumption being made in this section is that, when two local neighborh
oods of a graph are similar or identical, then this reflects some important
 similarity in the raw data.
 That is, similarity of subgraphs is the be-all and end-all of extracting
 knowledge from the larger graph, and that the primary goal is to search
 for, mine, such similar subgraphs.
\end_layout

\begin_layout Standard
Exactly what it means to be 
\begin_inset Quotes eld
\end_inset

similar
\begin_inset Quotes erd
\end_inset

 is not defined here; this is up to the user.
 Similarity could mean subgraph isomorphism, or subgraph homomorphism, or
 something else: some sort of 
\begin_inset Quotes eld
\end_inset

close-enough
\begin_inset Quotes erd
\end_inset

 similarity property involving the shape of the graph, the connections made,
 the colors, directions, labels and weights on the vertexes or edges.
 The precise details do not matter.
 However, it is assumed that the user can provide some algorithm for finding
 such similarities, and that the similarities can be understood as a kind-of
 
\begin_inset Quotes eld
\end_inset

equivalence relation
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
If one has an equivalence relation, then the obvious desire, the obvious
 urge is to attempt to perform quotienting on the graph.
 That is, to create a new graph, where the 
\begin_inset Quotes eld
\end_inset

equal
\begin_inset Quotes erd
\end_inset

 parts are merged into one.
 The rest of this document describes how this can be done, and what sort
 of notation to use to do this.
\end_layout

\begin_layout Standard
To motivate this, consider the following scenario.
 One has a large graph, some dense mesh, and one decides, via some external
 decision process, that two vertexes are similar.
 One particularly good reason to think that they are similar is that they
 share a lot of nearest neighbors.
 In a social graph, one might say they have a lot of friends in common.
 In genomic or proteomic data, they may interact with the same kinds of
 genes/proteins.
 In natural language, they might be words that are synonyms, and thus get
 used the same way across many different sentences; specifically, the syntactic
 dependency parse links these words to the same set of heads and dependents.
 At any rate, one has a large graph, and some sort of equivalence operation
 that can decide if two vertexes are the 
\begin_inset Quotes eld
\end_inset

same
\begin_inset Quotes erd
\end_inset

, or are 
\begin_inset Quotes eld
\end_inset

similar enough
\begin_inset Quotes erd
\end_inset

.
 Whenever one has an equivalence relation, one can apply it to obtain a
 quotient, of grouping together into an identity all things that are the
 same.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Creating a quotient graph
\end_layout

\end_inset


\begin_inset Graphics
	filename similar.eps
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout
The vertexes 
\begin_inset Quotes eld
\end_inset

walked
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ran
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

drove
\begin_inset Quotes erd
\end_inset

 can be considered similar, because they have the same neighbors.
 The upper graph can be simplified by computing a quotient, shown in the
 lower diagram: the quotient merges these three similar vertexes into one.
 The result is not only a simpler graph, but also some vague sense that
 
\begin_inset Quotes eld
\end_inset

walked
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ran
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

drove
\begin_inset Quotes erd
\end_inset

 are synonymous in some way.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In graph theory, there is a notion of quotienting, but it is not quite the
 same as what will be defined shortly.
 In graph theory, when working with quotients, one will typically consider
 a graph 
\begin_inset Formula $G$
\end_inset

 relative to some subgraph 
\begin_inset Formula $A\subset G$
\end_inset

.
 One effectively 
\begin_inset Quotes eld
\end_inset

draws a dotted line
\begin_inset Quotes erd
\end_inset

 or places a balloon around the vertexes in 
\begin_inset Formula $A$
\end_inset

, but preserves all of the edges coming out of 
\begin_inset Formula $A$
\end_inset

 and going into 
\begin_inset Formula $G$
\end_inset

.
 The internal structure of 
\begin_inset Formula $A$
\end_inset

 is then typically ignored, discarded; not out of spite, but because that
 is the nature of an equivalence relation: it states that all elements of
 
\begin_inset Formula $A$
\end_inset

 are 
\begin_inset Quotes eld
\end_inset

equal
\begin_inset Quotes erd
\end_inset

, are 
\begin_inset Quotes eld
\end_inset

equivalent
\begin_inset Quotes erd
\end_inset

, are one and the same, and thus 
\begin_inset Formula $A$
\end_inset

 behaves as if it were a single vertex, with assorted edges attached to
 it, running from 
\begin_inset Formula $A$
\end_inset

 to the rest of 
\begin_inset Formula $G$
\end_inset

.
\end_layout

\begin_layout Standard
By contrast, the goal here is not just to talk about a graph 
\begin_inset Formula $G$
\end_inset

 relative to a single 
\begin_inset Formula $A$
\end_inset

, but relative to a huge number of different 
\begin_inset Formula $A$
\end_inset

's.
 What's more, the internal structure of these 
\begin_inset Formula $A$
\end_inset

's will continue to be interesting, and so is carried onwards.
 Finally, the act of merging together multiple vertexes into one 
\begin_inset Formula $A$
\end_inset

 may result in some of the existing edges being cut, or new edges being
 created.
 The clustering operation applied to the graph alters the graph structure.
 These considerations are what makes it convenient to abandon traditional
 graph theory, and to replace it by the notion of sheaves and sections.
\end_layout

\begin_layout Standard
Given two vertexes 
\begin_inset Formula $v_{a}$
\end_inset

 and 
\begin_inset Formula $v_{b}$
\end_inset

, let 
\begin_inset Formula $s_{a}$
\end_inset

 and 
\begin_inset Formula $s_{b}$
\end_inset

 be the corresponding seeds, as defined previously.
 That is, 
\begin_inset Formula $s=\left(v,E_{v}\right)$
\end_inset

 with 
\begin_inset Formula $E_{v}$
\end_inset

 being the set of edges connecting 
\begin_inset Formula $v$
\end_inset

 to all of its nearest neighbors.
 Consider now creating the object 
\begin_inset Formula $\left(\left\{ v_{a},v_{b}\right\} ,E_{ab}\right)$
\end_inset

.
 This is no longer a seed, as the first item is no longer a single vertex,
 but a set of vertexes.
 The set 
\begin_inset Formula $E_{ab}$
\end_inset

 is still a set of edges, depending on the two initial sets of edges 
\begin_inset Formula $E_{a}$
\end_inset

 and 
\begin_inset Formula $E_{b}$
\end_inset

.
 The precise definition of 
\begin_inset Formula $E_{ab}$
\end_inset

 is not given: it might be the union of 
\begin_inset Formula $E_{a}$
\end_inset

 and 
\begin_inset Formula $E_{b}$
\end_inset

, or the intersection, or some other function.
 In general, one writes 
\begin_inset Formula $E_{ab}=f\left(E_{a},E_{b}\right)$
\end_inset

 for some function 
\begin_inset Formula $f$
\end_inset

.
 The result of creating this object is no longer strictly a graph, at least,
 not in the natural sense (one can force a graph structure onto the result,
 but doing so gets awkward).
 The mashing together of two vertexes creates a kind of a quotient, as described
 above.
 This quotient will be called a stalk in what follows.
\end_layout

\begin_layout Definition*
A 
\noun on
stalk
\noun default
 is an ordered pair 
\begin_inset Formula $S=\left(V,E\right)$
\end_inset

 of vertexes and edges such that every edge in 
\begin_inset Formula $E$
\end_inset

 has one endpoint being a vertex in 
\begin_inset Formula $V$
\end_inset

 and the other endpoint being a vertex not in 
\begin_inset Formula $V$
\end_inset

.
 That is, each edge in 
\begin_inset Formula $E$
\end_inset

 is a connector, and no edge in 
\begin_inset Formula $E$
\end_inset

 is a link (back into 
\begin_inset Formula $V)$
\end_inset

.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
This definition of a stalk is meant to be a straight-forward generalization
 of the previously defined seed, replacing the germ vertex by a germ that
 is a set of vertexes.
 Stalks can be linked together, much as seeds are:
\end_layout

\begin_layout Definition*
A 
\noun on
link
\noun default
 between two different stalks 
\begin_inset Formula $S_{a}=\left(V_{a},E_{a}\right)$
\end_inset

 and 
\begin_inset Formula $S_{b}=\left(V_{b},E_{b}\right)$
\end_inset

 is any edge 
\begin_inset Formula $e=\left(v_{1},v_{2}\right)$
\end_inset

 running between them, 
\emph on
viz.

\emph default
 where 
\begin_inset Formula $v_{1}\in V_{a}$
\end_inset

 and 
\begin_inset Formula $v_{2}\in V_{b}$
\end_inset

 and 
\begin_inset Formula $e\in E_{a}$
\end_inset

 and 
\begin_inset Formula $e\in E_{b}$
\end_inset

.
 Two stalks are 
\noun on
connected
\noun default
 when there are one or more links between them.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
It is convenient (it is suggested) that the vertexes in the stalk be visualized
 as being stacked one on top another, forming a tower or a fiber, with the
 edges sticking out as spines.
 Perhaps one can visualize a kind-of melted stack of jigsaw-puzzle pieces.
 This visualization is suggested only to enforce the idea that two different
 stalks project down to two different base-points.
 In particular, one now can have the notion of a meta-graph where each stalk
 is a vertex, and each link is an edge.
 That is, if one flattens the meta-graph down to two dimensions, then one
 can imagine a stalk growing up as a pole above each meta-vertex, and each
 meta-edge as being the projection of a link between two stalks.
 To maintain consistency with standard mathematical terminology, this meta-graph
 should really be called a 
\begin_inset Quotes eld
\end_inset

base space
\begin_inset Quotes erd
\end_inset

, and the stalks and links project down onto it in the usual sense.
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A stalk and it's projection
\end_layout

\end_inset


\begin_inset Graphics
	filename stalk.eps
	width 60col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The projection down to a base space suggests that the equivalence relation
 on vertexes can be extended to an equivalence relation on edges: two edges
 are equivalent if they form the same link.
 That is, one has an equivalence class of edges:
\end_layout

\begin_layout Definition*
A 
\noun on
link
\noun default
 between two different stalks 
\begin_inset Formula $S_{a}=\left(V_{a},E_{a}\right)$
\end_inset

 and 
\begin_inset Formula $S_{b}=\left(V_{b},E_{b}\right)$
\end_inset

 is the set 
\begin_inset Formula $l=\left\{ e_{k}\right\} $
\end_inset

 of all edges 
\begin_inset Formula $e_{k}$
\end_inset

 that connect some pair of vertexes in 
\begin_inset Formula $V_{a}$
\end_inset

 and 
\begin_inset Formula $V_{b}$
\end_inset

.
 That is, every 
\begin_inset Formula $e_{k}=\left(v_{k1},v_{k2}\right)$
\end_inset

 in 
\begin_inset Formula $L$
\end_inset

 has the property that 
\begin_inset Formula $v_{k1}\in V_{a}$
\end_inset

 and 
\begin_inset Formula $v_{k2}\in V_{b}$
\end_inset

 and 
\begin_inset Formula $e_{k}\in E_{a}$
\end_inset

 and 
\begin_inset Formula $e_{k}\in E_{b}$
\end_inset

.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
This redefines the notion of a link.
 Perhaps it should be given a different name, but it should be OK, because
 the intended sense should be clear from the context.
 This allows us to redefine the notion of a stalk as well:
\end_layout

\begin_layout Definition*
A 
\noun on
stalk
\noun default
 is an ordered pair 
\begin_inset Formula $S=\left(V,L\right)$
\end_inset

 of vertexes and links such that every link in 
\begin_inset Formula $L$
\end_inset

 has one endpoint that is 
\begin_inset Formula $V$
\end_inset

 and the other endpoint not being 
\begin_inset Formula $V$
\end_inset

.
 That is, each link in 
\begin_inset Formula $L$
\end_inset

 is a connector or half-edge.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
The above definition renders the stalk as being essentially the same thing
 as a seed, except that now, one is working with sets of vertices, and the
 links between them.
 
\end_layout

\begin_layout Subsection*
Why clustering?
\end_layout

\begin_layout Standard
The above establishes a vocabulary, a means for talking about the clustering
 of similar things on graphs.
 It does not suggest how to cluster.
 Without this vocabulary, it can be very confusing to visualize and talk
 about what is meant by clustering on a graph.
 Its worth reviewing some examples.
\end_layout

\begin_layout Itemize
In a social graph, a cluster might be a clique of friends.
 By placing these friends into one group, the stalk allows you to examine
 how different groups interact with one-another.
\end_layout

\begin_layout Itemize
In proteomic or genomic data, if one can group together similar proteins
 or genes into clusters, one can accomplish a form of dimensional reduction,
 simplifying the network model of the dataset.
 It provides a way to formalize network construction, without the bad smell
 of ad-hoc simplifications.
\end_layout

\begin_layout Itemize
In linguistic data, the natural clustering is that of words that behave
 in a similar syntactic fashion; such clusters are commonly called 
\begin_inset Quotes eld
\end_inset

grammatical classes
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

parts of speech
\begin_inset Quotes erd
\end_inset

.
 In particular, it allows one to visualize language as a graph.
 So: consider, for example, the set of all dependency parses of all sentences
 in some corpus, say Wikipedia.
 Each dependency parse is a tree; the vertexes are words, and the edges
 are the dependencies.
 Taken as a graph, this is a huge graph, with words connecting to other
 words, all over the place.
 Its not terribly interesting in this raw state, because its overwhelmingly
 large.
 However, we might notice that all sentences containing the word 
\begin_inset Quotes eld
\end_inset

dish
\begin_inset Quotes erd
\end_inset

 resemble all sentences containing the word 
\begin_inset Quotes eld
\end_inset

plate
\begin_inset Quotes erd
\end_inset

; that these two words always get used in a similar or the same way.
 Grouping these two words together into one reduces the size of the graph
 by one vertex.
 Aggressively merging similar words together can sharply shrink the size
 of the graph to a manageable size.
 One gets something more: the resulting graph can be understood as encapsulating
 the structure of the English language.
 
\end_layout

\begin_layout Standard
This last example is worth expanding on.
 Two things happen when the compressed graph is created.
 First, that graph encodes the syntactic structure of the language: the
 links between grammatical classes indicate how words can be arranged into
 grammatically correct sentences.
 Second, the amount of compression applied can reveal different kinds of
 structures.
 With extremely heavy compression, one might discover only the crudest parts
 of speech: determiners, adjectives, nouns, transitive and intransitive
 verbs.
 Each of these classes are distinct, because they link differently.
 However, if instead, a lot less compression is applied, then one can discover
 synonymous words: so, 
\begin_inset Quotes eld
\end_inset

plate
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

dish
\begin_inset Quotes erd
\end_inset

 might be grouped together, possibly with 
\begin_inset Quotes eld
\end_inset

saucer
\begin_inset Quotes erd
\end_inset

, but not with 
\begin_inset Quotes eld
\end_inset

cup
\begin_inset Quotes erd
\end_inset

.
 Here, one is extracting a semantic grouping, rather than a syntactic grouping.
 
\end_layout

\begin_layout Standard
So, the answer to 
\begin_inset Quotes eld
\end_inset

why clustering?
\begin_inset Quotes erd
\end_inset

 is that it allows information to be extracted from a graph, and encoded
 in a useful, usable fashion.
 No attempt is made here to suggest how to cluster; merely, that if an equivalen
ce relation is available, and if it is employed wisely, then one can construct
 quotient graphs that encode important relationships of the original, raw
 graph.
\end_layout

\begin_layout Subsection*
Similar concepts
\end_layout

\begin_layout Standard
One can think of a stalk as a kind of hypergraph, but this view does not
 seem to be particularly productive.
\end_layout

\begin_layout Section*
Types
\end_layout

\begin_layout Standard
It is notationally awkward to have to write stalks in terms of the sets
 of vertexes that they are composed of; it is convenient to instead replace
 each set by a symbol.
 The symbol will be called a 
\noun on
type
\noun default
.
 As it happens, these types can be seen to be the same things occurring
 in the study of type theory; the name is justified.
\end_layout

\begin_layout Standard
The core idea can be illustrated with Link Grammar as an example.
 The Link Grammar disjuncts 
\emph on
are
\emph default
 one and the same thing as stalks.
 It is worth making this very explicit.
 A subset of the Link Grammar English dictionary looks like this:
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family sans
cat dog: D- & S+;
\end_layout

\begin_layout Plain Layout

\family sans
the a: D+;
\end_layout

\begin_layout Plain Layout

\family sans
ran: S-;
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\begin_inset Newline newline
\end_inset

This states that 
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

 are both vertexes, and they are in the same stalk.
 That stalk has two connectors: 
\family sans
D-
\family default
 and 
\family sans
S+
\family default
, which encode the other stalks that can be connected to.
 So, the 
\family sans
D+
\family default
 can be connected to the 
\family sans
D-
\family default
 to form a link.
 The link has the form 
\family sans
({the, a}, {cat, dog})
\family default
 and the connector symbols 
\family sans
D+
\family default
 and 
\family sans
D-
\family default
 act as abbreviations for the vertex sets that the unconnected end can connect
 to.
 The + and - symbols indicate a directionality: to the right or to the left.
 The capture the notion that, in English, the word-order matters.
 To properly explain the + and -, we should have to go back to the definition
 of a graph on the very first page, and introduce the notion of left-right
 order among the vertices.
 Doing so from the very beginning would do nothing but clutter up the presentati
on, so that is not done.
 The reader is now invited to treat the initial definition of the graph
 as a monad: there are additional details 
\begin_inset Quotes eld
\end_inset

under the covers
\begin_inset Quotes erd
\end_inset

, but they are wrapped up and ignored, and only the relevant bits are exposed.
 Perhaps the vertices had a color.
 Perhaps they had a name, or a numerical weight; this is ignored.
 Here, we unwrap the idea that the vertices must be organized in a left-right
 order.
 Its sufficient, for now, to leave it at that.
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Three stalks and two typed links
\end_layout

\end_inset


\begin_inset Graphics
	filename grammar.eps
	width 40col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The three stalks here encode a set of grammatically valid English language
 sentences.
 Hooking together the S- and S+ connectors to form an S link, one obtains
 the sequence 
\family sans
[{the, a} {cat, dog} {ran}]
\family default
.
 This can be used to generate grammatically valid sentences: pick one word
 from each set, and one gets a valid sentence.
 Alternatively, this structure can be taken to encode the sum-total knowledge
 about this toy language: it is a kind-of graphical representation of the
 entire language, viewed as a whole.
\end_layout

\begin_layout Definition*
Given a stalk 
\begin_inset Formula $S=\left(V,L\right)$
\end_inset

, the 
\noun on
connector type
\noun default
 of 
\begin_inset Formula $L$
\end_inset

 is a symbol that can be used as a synonym for the set 
\begin_inset Formula $L$
\end_inset

.
 It serves as a short-hand notation for 
\begin_inset Formula $L$
\end_inset

 itself.
 
\begin_inset Formula $\diamond$
\end_inset


\end_layout

\begin_layout Standard
Just as in type theory, a type can be viewed a set.
 Yet, just as in type theory, this is the wrong viewpoint: a type is better
 understood as expressing a property: it is an intensional, rather than
 an extensional description.
 Formally, in the case of finite sets, this may feel like splitting hairs.
 For an intuitive understanding, however, its useful to think of a type
 as a property carried by an object, not just the class that the object
 can be assigned to.
\end_layout

\begin_layout Subsection*
Why types? 
\end_layout

\begin_layout Standard
Types are introduced here primarily as a convenience for working with stalks.
 They are labels, but they can be useful.
 Re-examining the examples:
\end_layout

\begin_layout Itemize
In a social graph, one group of friends might be called 
\begin_inset Quotes eld
\end_inset

students
\begin_inset Quotes erd
\end_inset

 and another group of friends might be called 
\begin_inset Quotes eld
\end_inset

teachers
\begin_inset Quotes erd
\end_inset

.
 The class labels are useful for noting the function and relationship of
 the different social groups.
\end_layout

\begin_layout Itemize
In a genetic regulatory network, sub-networks can be classified as "positive
 regulatory pathways" or "negative regulatory pathways" with respect to
 the activation of a particular gene.
\end_layout

\begin_layout Standard
These examples suggest that the use of types is little more than a convenient
 labeling system.
 In fact, more hay can be made here, as types interact strongly with category
 theory: types are used to describe the internal language of monoidal categories.
 But this is a rather abstract viewpoint, of no immediate short-term use.
 Suffice it to say that appearance of types in grammatical analysis of a
 language is not accidental.
 
\end_layout

\begin_layout Subsection*
What kind of information do types carry?
\end_layout

\begin_layout Standard
The above example oversimplifies the notion of types, presenting them as
 a purely syntactic device.
 In practice, types also carry semantic information.
 The amount of semantic information varies inversely to the broadness of
 the type.
 In language, coarse-grained types (noun, verb) carry almost no semantic
 information.
 Fine-grained types carry much more: a 
\begin_inset Quotes eld
\end_inset

transitive verb taking a particle and an indirect object
\begin_inset Quotes erd
\end_inset

 is quite specific: it must be some action that can be performed on some
 object using some tool in some fashion.
 An example would be 
\begin_inset Quotes eld
\end_inset

John sang a song to Mary on his guitar
\begin_inset Quotes erd
\end_inset

: there is a what, who and and how yoked together in the verb 
\begin_inset Quotes eld
\end_inset

sang
\begin_inset Quotes erd
\end_inset

.
 The more fine-grained the classification, the more semantic content is
 contained in it.
\end_layout

\begin_layout Standard
This suggests that the proper approach is hierarchical: a fine-grained clusterin
g, that captures semantic content, followed by a coarser clustering that
 erases much of this, leaving behind only 
\begin_inset Quotes eld
\end_inset

syntactic
\begin_inset Quotes erd
\end_inset

 content.
\end_layout

\begin_layout Section*
Parsing
\end_layout

\begin_layout Standard
The introduction remarked that not every collection of seeds can be assembled
 in such a way as to create a valid graph.
 This idea can be firmed up, and defined more carefully.
 Generically, a valid assembly of seeds is called a parse, and the act of
 assembling them is called parsing, which is done by parse algorithms.
 To illustrate the process, consider the following two seeds:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Formula $v_{2}:\left\{ \left(v_{2},v_{1}\right),\left(v_{2},v_{3}\right)\right\} $
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Formula $v_{3}:\left\{ \left(v_{3},v_{2}\right)\right\} $
\end_inset


\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Represented graphically, these seeds are
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Two unconnected seeds
\end_layout

\end_inset


\begin_inset Graphics
	filename bad-graph.eps
	width 55col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The connector (half-edge) 
\begin_inset Formula $\left(v_{2},v_{3}\right)$
\end_inset

 appears with both polarities, and can be linked together to form a link.
 The connector 
\begin_inset Formula $\left(v_{2},v_{1}\right)$
\end_inset

 has nothing to connect to.
 Even after maximally linking these two seeds, one does not obtain a valid
 graph: the vertex 
\begin_inset Formula $v_{1}$
\end_inset

 is missing from the vertex-set of the graph, even though there is an edge
 ready to attach to it.
 This provides an example of a failed parse.
 It is enough to add the seed 
\begin_inset Formula $v_{1}:\left\{ \left(v_{1},v_{2}\right)\right\} $
\end_inset

 to convert this into a successful parse.
 Adding this seed, and then attempting to maximally link it results in a
 valid graph; the parse is successful.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parsing is the creation of links
\end_layout

\end_inset


\begin_inset Graphics
	filename parsing.eps
	width 45col%

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the minor change in notation: the colon is used as a separator, with
 the germ appearing on the left, and set of connectors on the right.
 The relevance of this notational change becomes more apparent, if we label
 the vertexes in a funny way: let 
\begin_inset Formula $v_{1}$
\end_inset

 carry the label 
\begin_inset Quotes eld
\end_inset

the
\begin_inset Quotes erd
\end_inset

, and 
\begin_inset Formula $v_{2}$
\end_inset

 carry the label 
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Formula $v_{3}$
\end_inset

 carry the label 
\begin_inset Quotes eld
\end_inset

ran
\begin_inset Quotes erd
\end_inset

.
 The failed parse is meant to illustrate that 
\begin_inset Quotes eld
\end_inset

dog ran
\begin_inset Quotes erd
\end_inset

 is not a grammatically valid sentence, whereas 
\begin_inset Quotes eld
\end_inset

the dog ran
\begin_inset Quotes erd
\end_inset

 is.
 
\end_layout

\begin_layout Standard
Converting these seeds to also enforce left-right word-order requires the
 notation
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family sans
the: {(the, dog+)}
\end_layout

\begin_layout Plain Layout

\family sans
dog: {(dog, the-), (dog,ran+)}
\end_layout

\begin_layout Plain Layout

\family sans
ran: {(ran, dog-)}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
This notation is verbose, and slightly confusing.
 Repeating the germ as the first vertex in every connector is entirely unnecessa
ry.
 Write instead:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family sans
the: { dog+ }
\end_layout

\begin_layout Plain Layout

\family sans
dog: { the-, ran+}
\end_layout

\begin_layout Plain Layout

\family sans
ran: { dog- }
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The set-builder notation is unneeded, and perhaps slightly confusing.
 In particular, the word 
\begin_inset Quotes eld
\end_inset

dog
\begin_inset Quotes erd
\end_inset

 has two connectors on it; both must be connected to obtain a valid parse.
 The ampersand can be used to indicate the requirement that both connectors
 are required.
 This notation will also be useful in the next section.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "80col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family sans
the: dog+ ;
\end_layout

\begin_layout Plain Layout

\family sans
dog: the- & ran+ ;
\end_layout

\begin_layout Plain Layout

\family sans
ran: dog- ;
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
This brings us almost back to the previous section, but not quite.
 Here, we are working with seeds; previously we worked with stalks.
 Here, the connector type labels were not employed.
 In real-world use-cases, using stalks and type labels is much more convenient.
\end_layout

\begin_layout Standard
This now brings us to a first draft of a parse algorithm.
 Given an input set of vertices, it attempts to find a graph that is able
 to connect all of them.
\end_layout

\begin_layout Enumerate
Provide a dictionary 
\begin_inset Formula $D$
\end_inset

 consisting of a set of unconnected stalks.
 
\end_layout

\begin_layout Enumerate
Input a set of vertices 
\begin_inset Formula $V=\left\{ v_{1},v_{2},\cdots,v_{k}\right\} $
\end_inset

.
 
\end_layout

\begin_layout Enumerate
For each vertex in 
\begin_inset Formula $V$
\end_inset

, locate a stalk which contains that vertex in it's germ.
\end_layout

\begin_layout Enumerate
Attempt to connect all connectors in the selected stalks.
\end_layout

\begin_layout Enumerate
If all connectors can be connected, the parse is successful; else the parse
 fails.
\end_layout

\begin_layout Enumerate
Print the resulting graph.
 This graph can be described as a pair 
\begin_inset Formula $\left(V,E\right)$
\end_inset

 with 
\begin_inset Formula $V$
\end_inset

 the input set of vertexes, and 
\begin_inset Formula $E$
\end_inset

 the set of links obtained from fully connecting the selected stalks.
\end_layout

\begin_layout Standard
The above algorithm is 
\begin_inset Quotes eld
\end_inset

generic
\begin_inset Quotes erd
\end_inset

, and does not suggest any optimal strategy for the crucial steps 3 or 4.
 It also omits discussion of any further constraints that might need to
 be applied: perhaps the edges need to be directed; perhaps the resulting
 graph must be a planar graph (no intersecting edges); perhaps the graph
 must be a minimum spanning tree; perhaps the input vertexes must be arranged
 in linear order.
 These are additional constraints that will typically be required in some
 specific application.
\end_layout

\begin_layout Subsection*
Why parsing?
\end_layout

\begin_layout Standard
The benefit of parsing for the analysis of the structure of natural language
 is well established.
 Thus, an example of parsing in a non-linguistic domain is useful.
 Consider having used the above graph compression/vertex-edge clustering
 techniques to obtain a collection of stalks that describe genomic interactions.
 This collection provides the initial dictionary 
\begin_inset Formula $D$
\end_inset

.
 Now imagine a process where a certain specific set of genes are associated
 with some particular trait or reaction.
 Is this a complete set? Can it be said that their interactions are fully
 understood?
\end_layout

\begin_layout Standard
One way to answer these last two questions would be to apply the parse algorithm
, using the known dictionary, to see if a complete interaction network can
 be obtained.
 If so, then this new specific gene-set fits the general pattern.
 If not, if a complete parse cannot be found, then one strongly suspects
 that there remain one or more genes, yet undetermined, that also play a
 role in the trait.
 To find these, one might examine the stalks that might have been required
 to complete the parse: these will give hints as to the specific type of
 gene, or style of interaction to search for.
\end_layout

\begin_layout Standard
Thus, parsing new gene expressions and pathways offers a way of discovering
 whether they resemble existing, known pathways, or whether they are truly
 novel.
 If they seem novel, parsing also gives strong hints as to where to look
 for any missing pieces or interactions.
\end_layout

\begin_layout Subsection*
Is this really parsing?
\end_layout

\begin_layout Standard
The above description of parsing is sufficiently different from standard
 textbook expositions of natural language parsing that some form of an apology
 needs to be written.
 
\end_layout

\begin_layout Standard
The first step is to observe that the presented algorithm is essentially
 a simplified, generalized variation of the Link Grammar parsing algorithm.
\begin_inset CommandInset citation
LatexCommand cite
key "Sleator1993"

\end_inset

 The generalization consists in the removal of word-order and link-crossing
 constraints.
\end_layout

\begin_layout Standard
The second step is to observe that the theory of Link Grammar is more-or-less
 isomorphic to the theory of pregroup grammars
\begin_inset CommandInset citation
LatexCommand cite
key "Kart2014"

\end_inset

 (see 
\begin_inset CommandInset href
LatexCommand href
name "Wikipedia"
target "https://en.wikipedia.org/wiki/Pregroup_grammar"

\end_inset

); the primary differences being notational.
 The left-right directional Link Grammar connectors correspond to the left
 and right adjoints in a pregroup.
 A Link Grammar disjunct (that is, a seed) corresponds to a sequence of
 types in a pregroup grammar.
 The correspondence is more-or-less direct, except that link grammar is
 notationally simpler to work with.
\end_layout

\begin_layout Standard
The third step is to observe that the Link Grammar is a form of dependency
 grammar.
 Although the original Link Grammar formulation uses undirected links, it
 is straight-forward and unambiguous to mark up the links with head-dependent
 directional arrows.
\end_layout

\begin_layout Standard
The fourth step is to realize that dependency grammars (DG) and head-phrase-stru
cture grammars (HPSG) are essentially isomorphic.
 Given one, one can obtain the other in a purely mechanistic way.
 
\end_layout

\begin_layout Standard
The final step is to realize that most introductory textbooks describe parsers
 for a context-free grammar, and that, for general instructional purposes,
 such parsers are sufficient to work with HPSG.
 The priamry issue with HPSG and context-free language parsers is that they
 obscure the notion of linking together pieces; this is one reason why dependenc
y grammars are often favored: they make clear that it is the linkage between
 various words that has a primary psychological role in the human understanding
 of language.
 It should be noted that many researchers in the psychology of linguistics
 are particularly drawn to the categorial grammars; these are quite similar
 to the pregroup grammars, and are more closely related to Link Grammar
 than to the phrase-structure grammars.
\end_layout

\begin_layout Section*
Polymorphism
\end_layout

\begin_layout Standard
Any given vertex may participate in two or more seeds, independently from
 one-another.
 It is this statement that further sharpens the departure from naive graph
 theory.
 This is best illustrated by a practical example.
\end_layout

\begin_layout Standard
Consider a large graph, constructed from a large corpus of English language
 sentences.
 As subgraphs, it might contain the two sentences 
\begin_inset Quotes eld
\end_inset

A big fly landed on his nose
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

It will fly home
\begin_inset Quotes erd
\end_inset

.
 The vertex 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

 occurs as a noun (the subject, with dterminer and adjective) in one sentence,
 and a verb (with subject and object) in the other.
 Suppose that the equivalence relation, described in the clustering section,
 also has the power to discern that this one word should really be split
 into two, namely 
\begin_inset Formula $fly_{\mbox{noun}}$
\end_inset

 and 
\begin_inset Formula $fly_{\mbox{verb}}$
\end_inset

, and placed into two different stalks, namely, in the 
\begin_inset Quotes eld
\end_inset

noun
\begin_inset Quotes erd
\end_inset

 stalk in the first case, and the 
\begin_inset Quotes eld
\end_inset

verb
\begin_inset Quotes erd
\end_inset

 stalk in the second.
 Recall that these two stalks must be different, because the kinds of connectors
 that are allowed on a noun must necessarily be quite different from those
 on a verb.
 One is then lead to the image shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Polymorphism"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Polymorphism
\begin_inset CommandInset label
LatexCommand label
name "fig:Polymorphism"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename polymorph.eps
	width 75col%

\end_inset


\end_layout

\begin_layout Plain Layout
This figure illustrates a polymorphic assignment for the word 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

.
 It is split into two parts, the first, a noun, classed with other nouns,
 showing labeled connectors to determiners, adjectives, and a connector
 showing that nouns can act as the subject of a verb.
 The second class shows labeled connectors to subjects and objects, as is
 appropriate for transitive verbs.
 Underneath are the flattened raw seeds, showing the words 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cat
\begin_inset Quotes erd
\end_inset

 and the myriad of connectors on them.
 The flattened seeds cannot lead to grammatical linkages, as they mash together
 into one the connectors for different parts of speech.
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The point of the figure is to illustrate that, although the 
\begin_inset Quotes eld
\end_inset

base graph
\begin_inset Quotes erd
\end_inset

 may not distinguish one variant of a vertex from another, it is important
 to discover, extract and represent this difference.
 The concept of 
\begin_inset Quotes eld
\end_inset

polymorphism
\begin_inset Quotes erd
\end_inset

 applies, because the base vertex behaves as one of several distinct types
 in practice.
 There are several ways the above diagram can be represented textually.
 As before, the Link Grammar-style notation is used, as it is fairly clear
 and direct.
 One representation would be to expose the polymorphism only in the connectors,
 and not in the base vertex label:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
fly: (DET- & ADJ- & SUBJ+) or (SUBJ- & OBJ+);
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
A different possibility is to promptly split the vertex label into two,
 and ignore the subscript during the parsing stage:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout

\family typewriter
fly.noun cat: (DET- & ADJ- & SUBJ+);
\end_layout

\begin_layout Plain Layout

\family typewriter
fly.verb walk: (SUBJ- & OBJ+);
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Either way, the non-subscripted version of 
\begin_inset Formula $fly$
\end_inset

 behaves in a polymorphic fashion.
\end_layout

\begin_layout Standard
Note that the use of the notation 
\begin_inset Quotes eld
\end_inset


\family typewriter
or
\family default

\begin_inset Quotes erd
\end_inset

 to disjoin the possibilities denotes a choice function, and not a boolean-or.
 That is, one can choose either one form, or the other; one cannot choose
 both.
 During the parse, both possibilities need to be considered, but only one
 selected in the end.
 This implies that at least some fragment of linear logic is at play, and
 not boolean logic.
 (this should be expanded upon in future drafts).
\end_layout

\begin_layout Subsection*
Similar concept: part of speech
\end_layout

\begin_layout Standard
It is tempting to identify the connectors DET, ADJ, SUBJ, OBJ in the diagrams
 above with 
\begin_inset Quotes eld
\end_inset

parts of speech
\begin_inset Quotes erd
\end_inset

.
 This would be a mistake.
 In conventional grammatical analysis, there are half-a-dozen or a dozen
 parts of speech that are recognized: noun, verb, adjective, and so on.
 By contrast, these connector types indicate a grammatical role.
 That is, the disjunct 
\family typewriter
SUBJ- & OBJ+
\family default
 indicates a word that takes both a subject and an object: a transitive
 verb.
 That is, the disjunct is in essence a fine-grained part of speech, indicating
 not only verb-ness, but the specific type of verb-ness (transitive).
\end_layout

\begin_layout Standard
The Link Grammar English dictionary documents more than 100 connector types,
 these are subtyped, so that approximately 500 connectors might be seen.
 These connectors, when arranged into disjuncts, result in tens of thousands
 of disjuncts.
 That is, Link Grammar defines tens of thousands of distinct 
\begin_inset Quotes eld
\end_inset

parts of speech
\begin_inset Quotes erd
\end_inset

.
 The can be thought of as parts of speech, but they are quite fine-grained,
 far more fine-grained than any text on grammar might ever care to list.
\end_layout

\begin_layout Standard
If one uses a technique, such as MST parsing
\begin_inset CommandInset citation
LatexCommand cite
key "Yuret1998"

\end_inset

, and then extracts disjuncts, one might observe more than 6 million disjuncts
 and 9 million seeds on a vocabulary of 140K words.
 These are, again, in the above technical sense, just 
\begin_inset Quotes eld
\end_inset

parts of speech
\begin_inset Quotes erd
\end_inset

, but they are hyperfine-grained.
 The count is overwhelming.
 So, although it is techinically correct to call them 
\begin_inset Quotes eld
\end_inset

parts of speech
\begin_inset Quotes erd
\end_inset

, it is a conceptual error to think of a class that has six million representati
ves as if it were a class with a dozen members.
\end_layout

\begin_layout Subsection*
Similar concept: skip-grams
\end_layout

\begin_layout Standard
The N-gram
\begin_inset CommandInset citation
LatexCommand cite
key "Rosen1996"

\end_inset

 and the more efficient skip-gram
\begin_inset CommandInset citation
LatexCommand cite
key "Guthrie2006"

\end_inset

 models of semantic analysis provide somewhat similar tools for understanding
 connectivity, and differentiating different forms of connectivity.
 In a skip-gram model, one might extract two skip-grams from the above example
 sentences: 
\begin_inset Quotes eld
\end_inset

a fly landed
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

it fly home
\begin_inset Quotes erd
\end_inset

.
 A clustering process, such as adagram or word2vec might be used to classify
 these two strings into distinct clusters, categorizing one with other noun-like
 words, and the other with verb-like words.
 
\end_layout

\begin_layout Standard
The N-gram or skip-gram technique works only for linear, sequenced data,
 which is sufficient for natural language, but cannot be employed in a generic
 non-ordered graphical setting.
 To make this clear: a seed representation for the above would be: 
\begin_inset Quotes eld
\end_inset

fly: a- landed+
\begin_inset Quotes erd
\end_inset

 indicating that the word 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 (written as the connector 
\begin_inset Quotes eld
\end_inset

a-
\begin_inset Quotes erd
\end_inset

) comes sequentially before 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

, while the word 
\begin_inset Quotes eld
\end_inset

landed
\begin_inset Quotes erd
\end_inset

 (written as the connector 
\begin_inset Quotes eld
\end_inset

landed+
\begin_inset Quotes erd
\end_inset

) comes after.
 The other phrase has the representation 
\begin_inset Quotes eld
\end_inset

fly: it- home+
\begin_inset Quotes erd
\end_inset

.
 These two can now be employed in a clustering algorithm, to determine whether
 they fall into the same, or into different categories.
 If one treats the skip-grams, and the seeds as merely two different representat
ions of the same data, then applying the same algorithm to either should
 give essentially the same results.
\end_layout

\begin_layout Standard
The seed representation, however, is superior in two different ways.
 First, it can be used for non-sequential data.
 Second, by making clear the relationship between the vertex and its connectors,
 the connectors can be treated as 
\begin_inset Quotes eld
\end_inset

additional data
\begin_inset Quotes erd
\end_inset

, tagging the vertex, carrying additional bits of information.
 That additional information is manifested from the overall graph structure,
 and is explicit.
 By contrast, untagged N-grams or untagged skip-grams leave all such structure
 implicit and hidden.
\end_layout

\begin_layout Subsection*
Polymorphism and semantics
\end_layout

\begin_layout Standard
The concept of polymorphism introduced above lays a foundation for semantics,
 for extracting meaning from graphs.
 This is already hinted at by the fact that any English-language dictionary
 will provide at least two different definitions for 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

: one tagged as a noun, the other as a verb.
 The observation of hyperfine-grained parts of speech can push this agressively
 farther.
 
\end_layout

\begin_layout Standard
In a modern corpus of English, one might expect to observe the seeds 
\begin_inset Quotes eld
\end_inset

apple: green-
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

apple: iphone+
\begin_inset Quotes erd
\end_inset

.
 The disjuncts 
\begin_inset Quotes eld
\end_inset

green-
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

iphone+
\begin_inset Quotes erd
\end_inset

 can be interpreted as a kind-of tag on the word 
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

.
 Since there are exactly two tags in this example, they can be viewed as
 supplying exactly one bit of additional information to the word 
\begin_inset Quotes eld
\end_inset

apple
\begin_inset Quotes erd
\end_inset

.
 Effectively, a single apple has been split into two distinct apples.
 Are they really distinct, however? This can only be judged on the basis
 of some clustering algorithm that can assign tagged words to classes.
 Even very naive, unsophisticated algorithms might be expected to classify
 these two different kinds of apple into different classes; the extra bit
 of information carried by the disjunct is a bit of actual, usable information.
\end_layout

\begin_layout Standard
To summarize: the arrangement of vertexes into polymorphic seeds and sections
 enables the vertexes to be tagged with extra information.
 The tags are the connectors themselves: thier presence or absence carries
 information.
 That extra information can be treated as 
\begin_inset Quotes eld
\end_inset

semantic information
\begin_inset Quotes erd
\end_inset

, identifying different types or kinds, rather than as purely syntactic
 information about arrangments and relationships.
\end_layout

\begin_layout Section*
Sheaves
\end_layout

\begin_layout Standard
The classification and quotienting procedures cause the structure of the
 entire network to behave much like the mathematical concept of a 
\begin_inset Quotes eld
\end_inset

sheaf
\begin_inset Quotes erd
\end_inset

 studied in 
\begin_inset Quotes eld
\end_inset

sheaf theory
\begin_inset Quotes erd
\end_inset

.
 This is a rather abstract branch of mathematics, most of which offers relativel
y little insight into the problems being tackled here.
 Thus, the presentation here is informal, and lacks in rigor.
 The primary example is again drawn from linguistics, although examples
 in biochemistry and other fields can be found as well.
\end_layout

\begin_layout Standard
The canonical first step in corpus linguistics is to align text around a
 shared word or phrase:
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space \qquad{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="right" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly like a butterfly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
airplanes that
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly fishing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly away home
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly ash in concrete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
when sparks
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
let's
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly a kite
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
learn to
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
fly helicopters
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Each word is meant to be a vertex; edges are assumed to connect the vertexes
 together in some way.
 In standard corpus linguistics, the edges are always taken to join together
 neighboring words: these then form the 
\begin_inset Quotes eld
\end_inset

n-grams
\begin_inset Quotes erd
\end_inset

 that are commonly studied.
 Alternately, the phrases can be parsed with a dependency parser of one
 style or another, in which case the words are joined with (directed) edges
 that denote dependencies.
 Parsing with a head-phrase parser introduces additional vertexes, typically
 called NP, VP, S and so on.
 The resulting graphical structure is shown in the two figures below.
 The first figure shows alignment based on N-grams, where the phrases are
 taken as linear sequences of words, without any structure.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
N-gram corpus text alignment
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename corpus-ngram.eps
	width 50col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next figure shows alignment that results from an (unlabeled, undirected)
 dependency parse of the text.
 Most noticeable is that the determiner 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

 does not link to 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

 even though it stands next to it; instead, the determiner links to the
 noun it determines.
 This figure also shows 
\begin_inset Quotes eld
\end_inset

ash
\begin_inset Quotes erd
\end_inset

 as modifying 
\begin_inset Quotes eld
\end_inset

fly
\begin_inset Quotes erd
\end_inset

, which, as a dependency, is not exactly correct but does serve to illustrate
 the difference between the N-gram and the dependency alignment.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Dependency parse corpus text alignment
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename corpus-dep.eps
	width 75col%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both of these figures represent a graph that results from a corpus alignment,
 where all uses of a word have been collapsed (projected down) to a single
 node.
 The resulting graph is the graph of the language.
 
\end_layout

\begin_layout Standard
A collapsed graph like that might appear strange; why would one want to
 do that, if one has individual sentence data? The answer is that by collapsing
 in this way, one can accumulate statistics for large collections of sentences:
 one can find out which links are frequenctly seen, and which are rare.
 One can capture the affinity for pairs of words, by computing the mutual
 information between them.
 Through this kind of averaging, a global overvioew emerges.
 The local structure can be recaptured by extracting seeds from individual
 sentences, and then re-assembling these seeds into stalks, in a polymorphic
 fashion.
\end_layout

\begin_layout Standard
In some domains, one might not have specific sentences as sequences of words,
 but one might be able to observe specific activation networks.
 For example, in biology, if one specific gene is up-regulated, one can
 then try to view everything else that changed as a 
\begin_inset Quotes eld
\end_inset

sentence
\begin_inset Quotes erd
\end_inset

, a certain 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 within the global graph.
\end_layout

\begin_layout Standard
One way of visualizing this global graph is as a stack of sheets of paper,
 with one sentence written on each sheet.
 In biology, one might write down specific pathways or interaction networks
 on the individual sheets.
 The papers are stacked in such a way that words that are the same are always
 vertically above one-another.
 This 
\begin_inset Quotes eld
\end_inset

stacking
\begin_inset Quotes erd
\end_inset

 is where the term 
\begin_inset Quotes eld
\end_inset

sheaf
\begin_inset Quotes erd
\end_inset

 comes from.
 Each single sheet of paper is a 
\begin_inset Quotes eld
\end_inset

section
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Sections can be cut down, or they can be enlarged, yet each section must
 consist of a grammatically-correct sentence, phrase (or paragraph, or larger!
 ...
 or smaller, just a sentence fragment).
 The base space consists simply of the individual words in the language,
 each word being a vertex, connections between words being projections of
 the connections discovered from the N-grams, or dependency graphs, as the
 case may be.
 One can examine how the structure of language changes as words are removed
 from the base space: such changes correspond to the 
\begin_inset Quotes eld
\end_inset

restriction morphisms
\begin_inset Quotes erd
\end_inset

 of a sheaf.
 These restriction morphisms obey all of the axioms of a sheaf; this observation
 is what drives the peculiar naming convention given here.
 The reason this 
\begin_inset Quotes eld
\end_inset

works
\begin_inset Quotes erd
\end_inset

, that the axioms apply, is in fact rather shallow: it is because the seeds,
 as initially defined, behave very much like open sets, and when they are
 projected to the base space, they serve to cover the base space, much as
 a topological covering does.
 
\end_layout

\begin_layout Standard
The restriction morphisms appear to continue to satisfy the sheaf axioms
 even after projection (at least, at the informal level given here).
\end_layout

\begin_layout Subsection*
Why sheaves?
\end_layout

\begin_layout Standard
The primary reason for introducing this notion is to consolidate the otherwise
 vague idea of the 
\begin_inset Quotes eld
\end_inset

language graph
\begin_inset Quotes erd
\end_inset

.
 One has dueling notions: the graph of all sentences; the generative power
 of grammars.
 Surface realizations of language are studied in corpus linguistics, where
 differences in regional dialects, differences according to socio-economic
 status and politically motivated differences are found.
 However, these surface realizations are almost never refined into a grammar,
 and thus, one does not obtain a generative model of how different speakers
 in different socio-economic classes speak: corpus linguistics examples
 are just that: examples that are not further refined.
 By applying a pattern mining approach, the underlying grammar can be discovered
 computationally.
 But what is it, really, that is being discovered, other than some collection
 of grammatical classes and relations? By looking at the collection of all
 words, sentences and paragraphs in a corpus as if it were a sheaf, one
 gets a more 
\begin_inset Quotes eld
\end_inset

holistic
\begin_inset Quotes erd
\end_inset

 view of what language is: one can start seeing the 
\begin_inset Quotes eld
\end_inset

big picture
\begin_inset Quotes erd
\end_inset

, instead of just the trees.
 This holistic view is the primary point of this exercise.
\end_layout

\begin_layout Subsection*
Related ideas
\end_layout

\begin_layout Standard
As before, the 
\begin_inset Quotes eld
\end_inset

sections
\begin_inset Quotes erd
\end_inset

 presented above (sentence fragments) are presented minimally.
 In practice, sections will be adorned with additional information, such
 as frequency counts and mutual information values.
 Once clustering and quotienting has been performed, non trivial type tags
 become available.
\end_layout

\begin_layout Section*
Conclusion
\end_layout

\begin_layout Standard
This document presents a way of thinking about graphs that allows them to
 be decomposed into constituent parts fairly easily, and then brought together
 and reassembled in a coherent, syntactically correct fashion.
 It does so without having to play favorites among competing algorithmic
 approaches and scoring functions.
 It makes only one base assumption: that knowledge can be extracted at a
 symbolic level from pair-wise relationships between events or objects.
\end_layout

\begin_layout Standard
It touches briefly, all too briefly, on several closely-related topics,
 such as the application of category theory and type theory to the analysis
 of graph structure.
 These topics could be greatly expanded upon, possibly clarifying much of
 this content.
 It is now known to category theorists that there is a close relationship
 between categories, the internal languages that they encode, and that these
 are reflections of one another, reflecting through a theory of types.
 A reasonable but incomplete reference for some of this material is the
 HoTT book.
 It exposes types in greater detail, but does not cover the relationship
 between internal languages, parsing, and the modal logic descriptions of
 parsing.
 It is possible that there are texts in proof theory that cover these topics,
 but I am not aware of any.
\end_layout

\begin_layout Standard
This is a bit unfortunate, since I feel that much or most of what is written
 here is 
\begin_inset Quotes eld
\end_inset

well known
\begin_inset Quotes erd
\end_inset

 to computational proof theorists; unfortunately, that literature is not
 aimed at the data-mining and machine-learning crowd that this document
 tries to address.
 Additions, corrections and revisions are welcomed.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "lang"
options "naturemagdoi"

\end_inset


\end_layout

\end_body
\end_document
